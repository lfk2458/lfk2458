

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="医学院の工科狗">
  <meta name="keywords" content="">
  
    <meta name="description" content="相见恨晚！终于有篇文章能把 Git 给讲明白了0 本文摘要相信大家在日常工作中都会用到 Git，但可能对于刚接触到 Git 的同学们来说这种工具的使用还不是很熟练，或者是对于虽然能够规范使用 Git 来完成日常开发的同学们，但可能对于命令背后的原理或许还是一脸懵逼，因此本文希望用较为简单的语言，能够在 Git 的使用上给大家带来帮助或者能解决大家的部分疑惑。首先第 1 节带大家由浅入深的了解 Gi">
<meta property="og:type" content="article">
<meta property="og:title" content="相见恨晚！终于有篇文章能把 Git 给讲明白了">
<meta property="og:url" content="https://www.fengkai.online/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%EF%BC%81%E7%BB%88%E4%BA%8E%E6%9C%89%E7%AF%87%E6%96%87%E7%AB%A0%E8%83%BD%E6%8A%8AGit%E7%BB%99%E8%AE%B2%E6%98%8E%E7%99%BD%E4%BA%86.html">
<meta property="og:site_name" content="医学院の工科狗的博客">
<meta property="og:description" content="相见恨晚！终于有篇文章能把 Git 给讲明白了0 本文摘要相信大家在日常工作中都会用到 Git，但可能对于刚接触到 Git 的同学们来说这种工具的使用还不是很熟练，或者是对于虽然能够规范使用 Git 来完成日常开发的同学们，但可能对于命令背后的原理或许还是一脸懵逼，因此本文希望用较为简单的语言，能够在 Git 的使用上给大家带来帮助或者能解决大家的部分疑惑。首先第 1 节带大家由浅入深的了解 Gi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632d50e21a90414aab2bde95a9a1a0a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76b07690db34ff0b2203cd8ab549dce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cc893c62bfa45a5963ac16992d7de42~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934fedb4e314e83b3cf9ee59e31cc9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337d71f6d3ee4828832dd7125305a157~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559cabc7a29449708f39c0cdd5aaca2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff94221938584abfac3ebf1e7b57b6e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd8c3dc059e44beb06894b6aea46340~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/519a822fd4bd4232a1a308e5a08367ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8981852250b49ebbb8b027c878bbc72~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/648a6bd40f344435a241dc500b87c553~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b00bbbd36514c7ebf10b918b96c8411~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f24744283e04a6aacd57c832da8a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9263e1bac39457290f16a0462cc5ea3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3572185127c5465eb974d56fa088a186~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d926d804f144e5adfd043ba167ad7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fb8d0dc60bf4c7d85ded4c92eb90142~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03038eabf3e94ab18115a75029850492~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a848a148e4945e68d3031183c785532~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1f33ba9cef74ac6b069adeca8c2858d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7b78f8cb4d4b80af6e0baf5e0632d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb55dda19314dedb313a740a67f2427~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ef20d2678c4081bc71abafd102338a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3ab6da61284322886466d1d47b737e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f90afd865a4c16b6804d17913d433d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a48df64ab64a7a9498838ac9886bc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7530ec588e424b70b003b5f162b13ac9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f660cd1198334089b5dc401c2e7a4f6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89432a3f616f4b47bd2f2fcc9f6c30e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2de9df7b331a41a595a205566704c811~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b138e1f72bb5405ca3aa7acded22aadc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="og:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7339b3b51c25448194967744b77c1d99~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
<meta property="article:published_time" content="2023-04-27T13:04:40.000Z">
<meta property="article:modified_time" content="2023-05-28T13:38:08.620Z">
<meta property="article:author" content="医学院の工科狗">
<meta property="article:tag" content="Git">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632d50e21a90414aab2bde95a9a1a0a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp">
  
  
  
  <title>相见恨晚！终于有篇文章能把 Git 给讲明白了 - 医学院の工科狗的博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/fluid-extention.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.fengkai.online","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 80vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>医学院の工科狗的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="相见恨晚！终于有篇文章能把 Git 给讲明白了"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        医学院の工科狗
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-04-27 21:04" pubdate>
          2023年4月27日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          12k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          59 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
        <div class="scroll-down-bar">
          <i class="iconfont icon-arrowdown"></i>
        </div>
      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">相见恨晚！终于有篇文章能把 Git 给讲明白了</h1>
            
            
              <div class="markdown-body">
                
                <h2 id="相见恨晚！终于有篇文章能把-Git-给讲明白了"><a href="#相见恨晚！终于有篇文章能把-Git-给讲明白了" class="headerlink" title="相见恨晚！终于有篇文章能把 Git 给讲明白了"></a>相见恨晚！终于有篇文章能把 Git 给讲明白了</h2><h1 id="0-本文摘要"><a href="#0-本文摘要" class="headerlink" title="0 本文摘要"></a>0 本文摘要</h1><p>相信大家在日常工作中都会用到 Git，但可能对于刚接触到 Git 的同学们来说这种工具的使用还不是很熟练，或者是对于虽然能够规范使用 Git 来完成日常开发的同学们，但可能对于命令背后的原理或许还是一脸懵逼，因此本文希望用较为简单的语言，能够在 Git 的使用上给大家带来帮助或者能解决大家的部分疑惑。首先第 1 节带大家由浅入深的了解 Git 的一些原理，其次第 2 节具体针对 Git 的常用分支操作-合并的两种方式（merge 和 rebase）进行了讨论以及给出了这两种合并方式的使用建议，最后在附录中分类整理了一些关于合并操作的常用命令，方便大家快速查找使用。</p>
<h1 id="1-关于-Git-的一些基本原理"><a href="#1-关于-Git-的一些基本原理" class="headerlink" title="1 关于 Git 的一些基本原理"></a>1 关于 Git 的一些基本原理</h1><h2 id="1-1-Git-是什么—-版本控制"><a href="#1-1-Git-是什么—-版本控制" class="headerlink" title="1.1 Git 是什么—-版本控制"></a>1.1 Git 是什么—-版本控制</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632d50e21a90414aab2bde95a9a1a0a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。最初的目的是 LinusTorvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>那么什么是“版本控制”呢？我为什么要关心它呢？ 版本控制是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。简单来说就是用于管理多人协同开发项目的技术。如果在多人进行软件开发时没有使用版本控制，将会引发很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。下面总结了一些使用版本控制的优点：</p>
<p>● 实现跨区域多人协同开发</p>
<p>● 追踪和记载一个或者多个文件的历史记录</p>
<p>● 组织和保护你的源代码和文档</p>
<p>● 统计工作量</p>
<p>● 并行开发、提高开发效率</p>
<p>● 跟踪记录整个软件的开发过程</p>
<p>● 减轻开发人员的负担，节省时间，同时降低人为错误</p>
<p>因此，在多人开发中我们必须要使用版本控制，目前诞生了很多版本控制工具（如 Git、SVN、CVS），但是由于 Git 易于学习，占用空间小，性能快如闪电，以及方便的临时区域和多个工作流等特性，使 Git 成为影响力最大且使用最广泛的版本控制工具，下面我们将介绍 Git 的一些基本原理。</p>
<h2 id="1-2-Git-的工作流程原理"><a href="#1-2-Git-的工作流程原理" class="headerlink" title="1.2 Git 的工作流程原理"></a>1.2 Git 的工作流程原理</h2><h3 id="（1）工作区域"><a href="#（1）工作区域" class="headerlink" title="（1）工作区域"></a>（1）工作区域</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76b07690db34ff0b2203cd8ab549dce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>首先来介绍介绍下 Git 的工作区域，分为工作区、暂存区和仓库区，每个区域的转换关系如上图所示。</p>
<ul>
<li>工作区（workspace）：就是我们平时本地存放项目代码的地方；</li>
<li>暂存区（index/stage）：用于临时存放我们的改动，事实上它只是一个文件，保存即将提交到文件列表信息；</li>
<li>仓库区（Repository）：就是安全存放数据的位置，里面有你提交到所有版本的数据，可分为本地仓库和远程仓库（remote），也称为版本库。</li>
</ul>
<h3 id="（2）文件状态"><a href="#（2）文件状态" class="headerlink" title="（2）文件状态"></a>（2）文件状态</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cc893c62bfa45a5963ac16992d7de42~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>Git 中的文件可分为五种状态：</p>
<ul>
<li>untrack（未追踪）：未跟踪，此文件在文件夹中，但并没有加入到 git 库，不参与版本控制。 通过 git add 状态变为 Staged；</li>
<li>unmodified（未修改）：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，而变为 Modified。如果使用 git rm 移出版本库，则成为 Untracked 文件；</li>
<li>modified（已修改）：已修改表示修改了文件，但还没保存到数据库中；</li>
<li>staged（已暂存）：已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；</li>
<li>committed（已提交）：已提交表示数据已经安全地保存在本地数据库中。</li>
</ul>
<p>结合文件的五种状态和三个工作区域的对应关系，引出 Git 的基本工作流程如下：</p>
<p>（1）在工作区中修改文件 A。</p>
<p>（2）git add fileA，将更改的部分添加到暂存区。具体过程是：首先，它给 A 文件创建 1 个校验和添加到暂存区中。校验和可以理解为是一个文件的唯一索引，git 通过 SHA-1 这种哈希算法，遍历每一个文件，根据文件内容等信息，为文件创建索引，以后只要根据这个索引，我们就可以取出一个文件中的完整内容。然后，git 对当前的暂存区拍了一张照片，也就是我们所说的快照，并将快照放入版本库。快照里包括什么内容呢？快照里包括我们刚才说的文件索引和文件完整内容（类似于 key-value 的结构）。同时，git 采用内置的 blob 对象来存储这三个文件的快照。</p>
<p>（3）git commit 来提交更新，找到暂存区的文件，将快照永久性存储到仓库区中。具体过程是：首先，git 用一个内置的 tree 对象，把文件的目录结构保存下来。然后，git 在这个 tree 对象上又包了一层，创建了一个 commit 对象，这个 commit 对象也是我们说的 git 进行版本管理的最终对象。commit 对象里包含了 tree 对象，还包含作者、提交评论等信息。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934fedb4e314e83b3cf9ee59e31cc9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="（3）数据存储"><a href="#（3）数据存储" class="headerlink" title="（3）数据存储"></a>（3）数据存储</h3><p>以上我们了解到了 Git 的基本工作流程，那么 Git 是如何存储代码信息的？我们知道，Git 与其它版本控制系统不同的是，保存的不是文件的变化或者差异，而是一系列不同时刻的快照 。在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。 但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。 首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象， 而由多个分支合并产生的提交对象有多个父对象。</p>
<p>那么上述提到的快照是什么呢？快照就是在执行 git commit 时，对当前暂存区的情况拍摄的一张“照片“，这个照片中涵盖的若干信息将被存放到 git 版本库下。若干信息指的是什么？是文件的索引+文件的完整内容（key-value 结构），文件的目录结构，和提交信息，这三者分别用 git 内置的 blob，tree，commit 对象进行存储。</p>
<ul>
<li>blob: 在 git 中对应着”内容 (content)”, 约等于一整个文件（不包含文件名和文件 mode);</li>
<li>tree: 在 git 中对应着”目录 (directory)”, 正如每一个目录中可以存储文件或其他子目录一样，tree 的每一个节点可以是一个 blob, 或者另一个 tree;</li>
<li>commit: 对应着一次提交，保存着对一个顶层树对象的引用（对应着某个路径下的一份完整的内容） , 以及提交信息（包括父 commit);</li>
</ul>
<p>我们可以通过一个目录下的文件及结构来对应得到一组 git 对象，下图为文件/目录与 blob/tree 的对应关系：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337d71f6d3ee4828832dd7125305a157~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>简单来说，就是我们可以通过 HEAD 文件找到当前 branch, 通过当前 branch 找到一个 commit, 通过一个 commit 找到一个顶层目录对应的 tree 对象，一个 tree 对象又会根据目录下的子目录和文件结构对应地指向一组 tree 对象和 blob 对象。由此，可以得到一个：HEAD(ref) -&gt; branch -&gt; commit -&gt; tree -&gt; tree/blob 的指向图。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559cabc7a29449708f39c0cdd5aaca2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>因此，上面的由目录到 git 对象的对应关系可以被简化成：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff94221938584abfac3ebf1e7b57b6e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>在提交时，git 会从顶部向下 ([He1oise 校对、] 还是从底部往上）观看每一个 blob 和 tree, 然后复用那些能够复用（没有改变）的对象，创造出一棵局部复用的树，所谓 commit 就指向了这棵树。当然，这里我们不用去考虑说树中的一个节点为什么会有多个父节点，因为虽然我们认为树中的节点总只有一个父节点，但实际使用上如果我们只考虑自顶而下地观察，我们其实只能看到这个节点是否属于某一棵树。</p>
<p>于是，我们在提交过后，获得了一个 commit 对象，这个 commit 对象会指向其。git 所在的目录为根节点的 tree 对象。因此，我们能通过一个 commit 对象找到一个对应的 tree, 根据一个 tree 对象来递归地找到其子 tree 对象和 blob 对象，因而找到当前路径下的一份完整的内容。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd8c3dc059e44beb06894b6aea46340~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>到这里，我们就大概整明白了一个分支是如何对应顶层目录下的所有内容了。更进一步地发散开，我们已知一个 commit 可能有零到多个父 commit, 则可以进一步了解到，在一片 commit 组成的森林里，commit 只是指向某一棵树的指示牌而已。</p>
<h1 id="2-Git-的分支合并方式浅析"><a href="#2-Git-的分支合并方式浅析" class="headerlink" title="2 Git 的分支合并方式浅析"></a>2 Git 的分支合并方式浅析</h1><h2 id="2-1-分支是什么"><a href="#2-1-分支是什么" class="headerlink" title="2.1 分支是什么"></a>2.1 分支是什么</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/519a822fd4bd4232a1a308e5a08367ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>Git 的分支，从本质上来说它仅仅是指向提交对象的可变指针。 Git 的默认分支名字是 master。 在多次提交操作之后，我们其实已经有一个指向最后那个提交对象的 master 分支。 master 分支会在每次提交时自动向前移动。下面介绍下关于 Git 分支的一些基本概念：</p>
<ul>
<li><p>Head 指针：（1）指向当前所在的本地分支，我们可以看到上图中 Head 指向的是 Master 分支，说明当前是在 Master 分支上；（2）Head 指针随着提交操作自动向前移动</p>
</li>
<li><p>分支创建：git branch Dev ，会在当前所在的提交对象上创建一个指针。</p>
</li>
<li>分支切换：git checkout Dev ，这条命令做了两件事（1）将 Head 指针移动到 Dev 分支上（2）将工作目录恢复成 Dev 分支所指向的快照内容。</li>
<li>分支合并：当我们在 Master 和 Dev 分支各自提交了一次分支后，我们可以看到，提交历史已经产生了分叉，当我们想将 Dev 分支上的修改到 Master 分支上时，我们可以使用 git merge 来完成合并操作。git merge 可以合并一个或者多个分支到你已经检出的分支中， 然后它将当前分支指针移动到合并结果上。</li>
</ul>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8981852250b49ebbb8b027c878bbc72~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="">  </p>
<h2 id="2-2-分支的合并策略"><a href="#2-2-分支的合并策略" class="headerlink" title="2.2 分支的合并策略"></a>2.2 分支的合并策略</h2><p>我们在上一节中提到，merge 操作可以将两个分支的修改整合到一起。具体来说，git 会尝试通过两个分支的 commit 指针，分别向前追溯，找到这两个 commit 指针在历史上最近的一次共同提交点。Git 有几种不同的方法用来寻找这个共同提交，而这些方法就是所谓的“合并策略”。默认 git 会帮你自动挑选合适的合并策略，也可以通过 git merge -s 策略名字来强指定使用的策略类型。下面我们来介绍一下最常见的几种合并策略：Fast-foward，Recursice，Octopus 等。</p>
<h3 id="（0）Three-way-merge（三向合并原理）"><a href="#（0）Three-way-merge（三向合并原理）" class="headerlink" title="（0）Three-way-merge（三向合并原理）"></a>（0）Three-way-merge（三向合并原理）</h3><p>在正式介绍 git 的合并策略之前，我们可以先来看下这种几种策略共同会遵循的一个原理：三向合并原理（Three Way Merge），举例一个场景：假设有两个同学在各自的分支上对同一个文件进行修改，如下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/648a6bd40f344435a241dc500b87c553~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>这个时候我们需要合并两个分支成一个分支，如果我们只对这两个文件进行对比，那么在代码合并时，只知道这两个文件在第 20 行有差异，却不知道应该采纳谁的版本。如果我知道这个文件的原件“base”，那么通过和“原件”代码的对比就能推算出应该采用谁的版本：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b00bbbd36514c7ebf10b918b96c8411~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>图示可以看出，B 中的代码和 Base 一样，说明 B 中并没有对这行代码做修改，而 A 中的代码和 Base 不一样，说明 A 在 Base 的基础上对这行代码做了修改，那么 A 和 B 合并应该采用 A 中的内容。当然还有一种情况是三个文件的代码都不相同，这就需要我们自己手动去解决冲突了：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f24744283e04a6aacd57c832da8a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>从上面的例子可以看出采用 Tree-Way-Merge（也称为三向合并）原理来合并代码有个重要前提是可以找到两份代码的“原件”，而 git 因为记录了文件的提交历史，再通过自身的合并策略就可以找到两个 commit 的公共 commit 是哪个，从而通过比对代码来进行合并。</p>
<h3 id="（1）Fast-forward-amp-Already-Up-To-Date（退化）"><a href="#（1）Fast-forward-amp-Already-Up-To-Date（退化）" class="headerlink" title="（1）Fast forward &amp; Already Up-To-Date（退化）"></a>（1）Fast forward &amp; Already Up-To-Date（退化）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9263e1bac39457290f16a0462cc5ea3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="">      </p>
<p>Fast foward 是最简单的一种合并策略，如图将 feature 分支合并到 dev 分支上，git 只需要将 dev 分支的指向最后一个 commit 节点上。Fast forward 是 git 在合并两个没有分叉的分支时的默认行为，如果你想禁用掉这种行为，明确拥有一次合并的 commit 记录，可以使用 git merge —no-ff 命令来禁用掉。</p>
<h3 id="（2）Recursive"><a href="#（2）Recursive" class="headerlink" title="（2）Recursive"></a>（2）Recursive</h3><p>Recursive 是 git 中最重要也是最常用的合并策略，简单概述为：通过算法寻找两个分支的最近公共祖先节点，再将找到的公共祖先节点作为 base 节点使用三向合并的策略来进行合并。举个例子：圆圈里的字母为当前 commit 中的内容，当我们要合并 C2，C3 两个节点时，先找到他们的公共祖先节点 C1，接着和节点 C1 的内容进行对比，因为 1 的内容是 A，所以 C3 并没有修改内容，而 C2 将内容改成 B，所以最后的合并结果 C4 的内容也是 B。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3572185127c5465eb974d56fa088a186~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>但是可能有更复杂的情况，出现几个分支相互交叉的情况（Criss-Cross 现象）, 如下图所示，当我们在寻找最近公共祖先时，可以找到两个节点：节点 C2 和节点 C3，根据不同公共祖先，可以分为两种情况：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d926d804f144e5adfd043ba167ad7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>（1）节点 C3 作为 base 节点</p>
<p>通过三向合并策略合并（base 节点的内容是 A，两个待合并分支节点的内容是 B 和 C）我们是无法得出应该使用哪个节点内容的，需要自己手动解决冲突。</p>
<p>（2）节点 C2 作为 base 节点</p>
<p>通过三向合并策略合并（base 节点的内容是 B，两个待合并分支节点的内容是 B 和 C）可以得出应该使用 C 来作为最终结果。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fb8d0dc60bf4c7d85ded4c92eb90142~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>通过上述分析，我们可以得知正确的合并结果应该是 C，那么 git 要如何保证自己能找到正确的 base 节点，尽可能的减少代码的合并冲突呢？实际上 git 在合并时，如果查找发现满足条件的祖先节点不唯一，那么 git 会首先合并满足条件的祖先节点们，将合并完的结果作为一个虚拟的 base 节点来参与接下来的合并。如上图所示：git 会首先合并节点 C2 和节点 C3，找到他们的公共祖先节点 1，在通过三项合并策略得到一个虚拟的节点 C23，内容是 B，再将节点 C23 作为 base 节点，和节点 5，节点 6 合并，比较完后得出最终版本的内容应该是 C。</p>
<h3 id="（3）Octopus（复杂化）"><a href="#（3）Octopus（复杂化）" class="headerlink" title="（3）Octopus（复杂化）"></a>（3）Octopus（复杂化）</h3><p>Octopus 策略可以让我们优雅的合并多个分支。前面我们介绍的策略都是针对两个分支的，如果现在有多个分支需要合并，使用 Recursive 策略进行两两合并会产生大量的合并记录：每合并其中两个分支就会产生一个新的记录，过多的合并提交出现在提交历史里会成为一种“杂音“，对提交历史造成不必要的”污染“。Octopus 在合并多个分支时只会生成一个合并记录，这也是 git 合并多个分支的默认策略。如下图：在 dev 分支下执行 git merge feature1 feature2。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03038eabf3e94ab18115a75029850492~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="2-3-分支的另外一种合并操作：Rebase"><a href="#2-3-分支的另外一种合并操作：Rebase" class="headerlink" title="2.3 分支的另外一种合并操作：Rebase"></a>2.3 分支的另外一种合并操作：Rebase</h2><h3 id="（1）场景举例"><a href="#（1）场景举例" class="headerlink" title="（1）场景举例"></a>（1）场景举例</h3><p>我们举一个实际应用的例子来引出 Rebase 操作，设想两种场景：（1）多人共用一个分支开发，且本地分支落后远程分支，需更新 （2）一个分支单人开发，且当前研发分支落后于主干分支，需更新</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a848a148e4945e68d3031183c785532~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>其实，上述两种情况都可抽象为上图所示，由第（1）种情况来举例，假如有多人在同一个分支上开发，C1、C2 为远端分支的提交，C3、C4 为我们在本地仓库的提交还没有推送到远端，如果这个时候另外一个同学将他的提交记录 C5 推送到了远端，这时，我们再想把我们的本地的提交推送到远端时，就需求有一个更新远程仓库并且合并本地分支的操作，目的是将其它同学提交记录也保留下来。那么如何更新呢？有两种办法：（1）git pull （2）git pull —rebase，我们可以先来看下这两种操作所带来的结果：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1f33ba9cef74ac6b069adeca8c2858d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt="">    其中，左图为 git pull 的操作后的提交历史，我们可以看到在本地分支多了一次合并记录 C6，这是由于 git pull 等同于 git fetch + git merge 操作，先从远端拉取分支，接着再执行合并操作（如有冲突需解除冲突），因此增加了一次提交记录 C6；</p>
<p>图 5 为执行 git pull —rebase 操作，可以看到我们本地的提交直接变基到了 C5 后面，而且没有增加提交记录，呈现出一条直线，这是因为 git pull —rebase 这个操作其实可以拆分为 fetch+rebase 操作，先从远端同步分支，接着再执行 rebase 操作。所以说这两个命令其实差别是在拉取分支后是执行了 merge 操作，还是 rebase 操作。</p>
<h3 id="（2）Rebase-原理"><a href="#（2）Rebase-原理" class="headerlink" title="（2）Rebase 原理"></a>（2）Rebase 原理</h3><p>我们可以看到，经过 merge 更新操作远程此时也变成了非直线形式，且有多了一次 merge 记录，而 rebase 更新操作此时变成了一条直线形式，且没有增加提交记录。目前可以总结下，rebase 有以下特点：</p>
<p>（1）Rebase 之后会改变提交历史记录，分支不再岔开，而是变成了一条直线；</p>
<p>（2）rebase 之后如果有冲突，解冲突时需把每次的 commit 都解一遍；</p>
<p>（3）rebase 之后没有保留 merge 记录，意味着没有保存这步的操作，而 git 的意义不就是保存记录吗？</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7b78f8cb4d4b80af6e0baf5e0632d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>为什么采用 rebase 方式来完成合并操作会有 merge 有这么多的不同呢？其实所谓的变基 (rebase), 指的就是将提交到某一分支的所有修改在另一分支上再应用一次，也就是想修改移动到另一个分支上。看上去就好像是其 base commit 发生了变化。我们可以从 git 源码上得知，rebase 就是调用了多次 merge。</p>
<p>我们可以从一个例子上直观表示一下 rebase 每一步都做了什么，如下图所示：在 feature 上 rebase dev 时，git 会以 dev 分支对应的 commit 节点作为起点，将 feature 上 commit 节点”变基“至 dev commit 的后面，并且会创建全新的 commit 节点来替代之前 commit，实际上 rebase 操作可以拆分成一系列的 merge 操作，现在我们看一下 rebase 的过程中 git 所做的事情：首先我们需要以 C1 作为 base 节点，C2 和 C4 进行合并生成新的 C5，然后再将 C5 的 parent 指向 C4。C3 到 C6 转变进行了同样的步骤。因为相比较之前的 commit，新的 commit 的 parent 变了，对应的 hash 值自然也变了。因此我们在 rebase 的时候，当前分支有几个 commit 记录那么 git 就需要进行合并几次。如果当前分支比较”干净“，只有一个 commit 记录的话，那么你 rebase 需要解的冲突其实和 merge 是一样的，区别就是 rebase 不会单独生成一个新的 commit 来记录这次合并。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb55dda19314dedb313a740a67f2427~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h2 id="2-4-关于-Merge-和-Rebase-的一些讨论"><a href="#2-4-关于-Merge-和-Rebase-的一些讨论" class="headerlink" title="2.4 关于 Merge 和 Rebase 的一些讨论"></a>2.4 关于 Merge 和 Rebase 的一些讨论</h2><h3 id="（1）Rebase-的一些问题"><a href="#（1）Rebase-的一些问题" class="headerlink" title="（1）Rebase 的一些问题"></a>（1）Rebase 的一些问题</h3><ul>
<li>Rebase 会修改历史记录</li>
</ul>
<p>大家可能都看过 git 文档 (pro-git) 里的经典戒律：Do not rebase commits that exist outside your repository and that people may have based work on. 如果在你的 repo 外，有人基于你的某些 commit 在开发，那么你就不应该对这些 commit 做 rebase. 文档里说得很严重，如果你不遵守这条准则，或者说是戒律，你会被人民仇恨，会被亲友唾弃。之所以整这么严重，是因为 rebase 操作的实质是丢弃一些既有的提交，然后相应地新建一系列变更内容相同但不一样的 commit 对象。如果这个提交在 rebase 前被推到了远端共享，而且其他人也在基于它做开发，那么当他们试图提交的时候，就得做所谓的 remerge 了。不论是 merge 还是 rebase, 合并行为都会发生，并导致有端点 (commit) 被提交。只不过在 rebase 中，合并发生在被依次应用每个差量，伴随着在一个分支中创建来自另一个分支的变更的线性历史而完成。而普通的三路合并则仅仅修改端点本身。</p>
<ul>
<li>Rebase 可能会导致一系列错误的提交</li>
</ul>
<p>rebase 除了修改历史记录之外，还有更深远的效果：rebase 会导致一系列新的提交。虽然这些提交组合起来，最后会达到相同的最终状态，但中间的提交有新的 SHA-1, 基于新的初始状态，代表不同的差异。因此，相较于 merge, rebase 的典型问题是：它事实上被视为”将源分支上的所有修改逐项地应用到目标分支上”, 就之前提到的：”两种整合方法在分支的最终结果上文件内容与结构上毫无区别”, 但也仅此而已——这些因为逐项应用产生的新提交对应的版本在现实里从来没有存在过，没有人真正生产了这些提交，也没有人能证明它们是可行的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ef20d2678c4081bc71abafd102338a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>我们看一个例子：在 commit2 中定义了一个函数，接受数字或字符串类型。在 commit4 中调用了这个函数，传入了一个数字。紧接着由于函数 func 维护的同学通知说从 commit3 以后不兼容数字形式了，需要依赖方做修改 (page/page2). 因此，在 commit5 中，我们添加上了对类型的修正。这个时候去 rebase 代码，将 commit4 和 commit5 迁移成 commit4’和 commit5’, 这个时候，commit5’是完全正确且安全的，但是如果我们 commit5 里有错误，希望回退到 commit4’去，问题就大条了。因为 commit4’事实上没有任何人测试过，也不是开发者特意上传的内容。而且可以看见，在这个例子里，是完全通不过类型系统的检查的。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3ab6da61284322886466d1d47b737e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="（2）其它相关场景举例"><a href="#（2）其它相关场景举例" class="headerlink" title="（2）其它相关场景举例"></a>（2）其它相关场景举例</h3><p>我们曾经在团队内部做了一个关于 merge 和 rebase 合理使用的调查问卷，有一个建议是希望能够从二者的原理出发，case by case 来分析场景和规避途径，下面列出了一些作者本人或同事们在实际开发中遇到的一些问题场景：</p>
<h4 id="场景-1：谨慎使用-force-push"><a href="#场景-1：谨慎使用-force-push" class="headerlink" title="场景 1：谨慎使用 force push"></a>场景 1：谨慎使用 force push</h4><p>首先来分享下团队内部曾经在 git 上踩过的坑：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f90afd865a4c16b6804d17913d433d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>如上图所示，A 同学和 B 同学共用一个研发分支，B 同学已经提交了两次 commit 并推送到了远端。之后，A 同学也已经开发完成，我们可以看到 A 同学的本地仓库分支已经落后于远端，理应先从远端更新分支，再推送到远端。但是 A 同学没有这么做，如下图所示，而是直接 force push 了上去，就导致了下面这种情况，B 同学的 C3、C4 提交记录被“丢弃”掉了。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a48df64ab64a7a9498838ac9886bc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>此时的补救的方法可以是：B 同学更新远端分支（git pull 或 git pull —rebase），再提交上去，提交历史变为下图：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7530ec588e424b70b003b5f162b13ac9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>那么我们应该如何避免这个问题呢：</p>
<p>（1）提交代码时谨慎使用 force push，建议使用 push（原因：如果我们使用 push 推送时，本地分支落后远端时会有提示）</p>
<p>（2）A 正确提交方法：先更新本地分支，再推送到远端。</p>
<p>我们如何更新本地分支：两种方法 merge 或 rebase，下面是两种命令更新后的分支示意图</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f660cd1198334089b5dc401c2e7a4f6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>我们可以看到，采用 merge 更新的方式，多了一条合并记录 C6，而 rebase 则是直接把记录从 C5 变更到了 C4’提交的后面且没有多一次的提交记录。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89432a3f616f4b47bd2f2fcc9f6c30e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="场景-2：rebase-解冲突"><a href="#场景-2：rebase-解冲突" class="headerlink" title="场景 2：rebase 解冲突"></a>场景 2：rebase 解冲突</h4><p>我们知道，在采用 rebase 方式更新代码时，如果有冲突 解冲突时需把每次的 commit 都解一遍。我们设想这样一种场景，feature 分支上共有三次提交，我们在解决冲突 1 和冲突 2 时如果包含了第三次提交的全部变动内容，我们在推代码后会神奇的发现 C5 记录不见了，这是因为 rebase 合并的实质是丢弃掉原有的提交，而另创建与原提交记录“相似”的提交，通过上述方式解冲突后，新的 C5’已经没有任何新的改动，所以 C5 会被“丢弃掉”。</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2de9df7b331a41a595a205566704c811~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h4 id="场景-3：merge-和-rebase-的提交历史差异"><a href="#场景-3：merge-和-rebase-的提交历史差异" class="headerlink" title="场景 3：merge 和 rebase 的提交历史差异"></a>场景 3：merge 和 rebase 的提交历史差异</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b138e1f72bb5405ca3aa7acded22aadc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<p>我们可以直观看到，经过 rebase 更新操作提交历史变成了一条直线形式，而经过 merge 更新操作远程的提交历史为非直线形式，且因为更新（而不是合并）多了一次 merge 记录。但是 rebase 也有很多缺点：</p>
<p>（1）rebase 之后 如果有冲突 解冲突时需把每次的 commit 都解一遍。</p>
<p>（2）rebase 之后没有保留 merge 记录，意味着没有保存这步的操作，而 git 的意义不就是保存记录吗？</p>
<p>但是如果我们换一种思路考虑，我们在本地分支中使用 rebase 来更新，是为了让我们的本地提交记录更加清晰可读。（当然， rebase 不只用来合并 master 的改动，还可以在协同开发时 rebase 队友的改动）而主分支中使用 merge 来把 feature 分支的改动合并进来，是为了保留分支信息。那么如何合适的使用 rebase 和 merge 呢？假如全使用 merge 就会导致提交历史繁复交叉，错综复杂。如果全使用 rebase 就会让你的 commits history 变成一条光秃秃的直线。因此，一个好的 commits history，应该是这样的，有合并记录且分支不交错：</p>
<pre><code class="hljs">*   e2e6451 (HEAD -&gt; master) feture-c finished
|\
| * 516fc18 C.2
| * 09112f5 C.1
|/
*   c6667ab feture-a finished
|\
| * e64c4b6 A.2
| * 6058323 A.1
|/
*   2b24281 feture-b finished
复制代码
</code></pre><p>而不应该是这样的，分支交错，看起来很混乱：</p>
<pre><code class="hljs">*   9f0c13b (HEAD -&gt; master) feture-c finished
|\
| * 55be61c C.2
| *   e18b5c5 merge master
| |\
| |/
|/|
* |   ee549c2 feture-a finished
|\ \
| * | 51f2126 A.3
| * |   72118e2 merge master
| |\ \
| |/ /
|/| |
* | |   6cb16a0 feture-b finished
|\ \ \
| * | | 7b27b77 B.3
| * | | 3aac8a2 B.2
| * | | 2259a21 B.1
|/ / /
| * | 785fab7 A.2
| * | 2b2b664 A.1
|/ /
| * bf9e77f C.1
|/
* 188abf9 init
复制代码
</code></pre><p>也不应该是这样的，完全呈一条直线，没有任何的合并记录：</p>
<pre><code class="hljs">* b8902ed (HEAD -&gt; master) C.2
* a4d4e33 C.1
* 7e63b80 A.3
* 760224c A.2
* 84b2500 A.1
* cb4c4cb B.3
* 2ea8f0d B.2
* df97f39 B.1
* 838f514 init
复制代码
</code></pre><h3 id="（3）Merge-和-Rebase-的对比以及使用建议"><a href="#（3）Merge-和-Rebase-的对比以及使用建议" class="headerlink" title="（3）Merge 和 Rebase 的对比以及使用建议"></a>（3）Merge 和 Rebase 的对比以及使用建议</h3><p>我们通过上述例子得知，rebase 和 merge 不是二选一的关系，要协同使用。当开发只属于自己的分支时尽量使用 rebase，减少无用的 commit 合到主分支里，多人合作时尽量使用 merge，一方面减少冲突，另一个方面也让每个人的提交有迹可循。按照上述思路来说，我们按照如下规则可以合理使用 rebase 和 merge 操作：</p>
<p>（1）如果我们只注重于更新操作时，rebase 操作可能会更好些，因为没必要多生成一个除了开发外的 merge 记录，也可以让我们的本地提交记录清晰可读。</p>
<p>（2）当我们要把研发分支合入到主干时，我们更注重的是合并的操作，保留合并的记录，这个时候用 merge 会好些。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>merge</th>
<th>rebase</th>
</tr>
</thead>
<tbody>
<tr>
<td>- 原理</td>
<td>三路合并</td>
<td>多次 merge</td>
</tr>
<tr>
<td>- 对历史的看法</td>
<td>“提交”的历史</td>
<td>“变更”的历史</td>
</tr>
<tr>
<td>- 对历史的态度</td>
<td>我们应当保留每一次提交的现场，不应该对其做修改。</td>
<td>我们应当使变更足够明晰，每一次变更的内容和在提交链上的位置应当能体现出它的用途何目的。</td>
</tr>
<tr>
<td>- 优点/缺点：</td>
<td></td>
<td></td>
</tr>
<tr>
<td>（1）是否保留合并记录</td>
<td>保留合并记录✅</td>
<td>不会保留合并记录</td>
</tr>
<tr>
<td>（2）历史提交记录</td>
<td>分支交错</td>
<td>提交记录呈直线型更清爽</td>
</tr>
<tr>
<td>（3）更新代码提交记录</td>
<td>更新代码时会增加一条合并记录</td>
<td>更新代码时不会增加合并记录✅</td>
</tr>
<tr>
<td>（4）解冲突</td>
<td>合并代码有冲突时，只需解决一次✅</td>
<td>每个 commit 都需要分别解冲突</td>
</tr>
<tr>
<td>- 适用场景</td>
<td></td>
<td></td>
</tr>
<tr>
<td>（1）feature 分支合入主干</td>
<td>保留合并记录✅</td>
<td></td>
</tr>
<tr>
<td>（2）更新代码</td>
<td>落后主干提交过多时预计冲突较多✅</td>
<td>更新代码时，且预计冲突不多✅</td>
</tr>
</tbody>
</table>
</div>
<h1 id="附录-Git-合并常用命令汇总整理"><a href="#附录-Git-合并常用命令汇总整理" class="headerlink" title="附录 Git 合并常用命令汇总整理"></a>附录 Git 合并常用命令汇总整理</h1><p>假设当前在 feature 分支，公共开发分支为 feature，示意图如下：</p>
<p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7339b3b51c25448194967744b77c1d99~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" srcset="/img/loading.gif" lazyload alt=""></p>
<h3 id="（1）merge"><a href="#（1）merge" class="headerlink" title="（1）merge"></a>（1）merge</h3><pre><code class="hljs"># feature 分支与 dev 分支合并
git merge dev 

# 禁用自动提交
git merge --no-commit dev 

# 禁用快进合并（保留 merge 记录）
git merge --no-ff dev

# 将 dev 分支的 commit 压缩成一个再合并
git merge --squash dev

# 指定合并策略（如 ours、subtree，默认为 recursive 和 octopus）
git merge -s &lt;strategy&gt; dev

# 显示详细的合并结果信息
git merge -v dev

# 显示合并的进度信息（不显示--no-progress）
git merge -progress dev

# 创建合并节点时的提交信息
git merge -m &quot;&quot; dev

# 合并冲突
git merge --continue

# 抛弃当前合并冲突的处理过程并尝试重建合并前的状态
git merge --abort
复制代码
</code></pre><h3 id="（2）rebase"><a href="#（2）rebase" class="headerlink" title="（2）rebase"></a>（2）rebase</h3><pre><code class="hljs"># 将 feature 分支变基到 dev 分支上 
git rebase dev

# 交互式修改或合并 commit 记录，详细使用可见 https://www.jianshu.com/p/4a8f4af4e803
git rebase -i [startpoint]  [endpoint]

# 拉取远程分支后采用 rebase 方式合并代码
git pull --rebase

# 合并冲突
git rebase --continue

# 将 feature 分支从 feature0 分支变基到到 master
git rebase --onto master feature0

# 放弃此次 rebase
git rebase --abort
复制代码
</code></pre><h3 id="（3）cherry-pick"><a href="#（3）cherry-pick" class="headerlink" title="（3）cherry-pick"></a>（3）cherry-pick</h3><pre><code class="hljs"># 把其他分支的某一个 commit 合入到当前分支
git cherry-pick &lt;commit id&gt; 

# 合并中有冲突，解决完后需要执行下面命令
git cherry-pick --continue
复制代码
</code></pre>
                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B/" class="category-chain-item">编程</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Git/">#Git</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>相见恨晚！终于有篇文章能把 Git 给讲明白了</div>
      <div>https://www.fengkai.online/软件教程/Git/相见恨晚！终于有篇文章能把Git给讲明白了.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>医学院の工科狗</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年4月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="NC - 非商业性使用">
                    <i class="iconfont icon-nc"></i>
                  </span>
                </a>
              
                <a target="_blank" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">
                  <span class="hint--top hint--rounded" aria-label="SA - 相同方式共享">
                    <i class="iconfont icon-sa"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html" title="十进制转成二进制的两种方式">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">十进制转成二进制的两种方式</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MySQL.html" title="Docker 安装 MySQL">
                        <span class="hidden-mobile">Docker 安装 MySQL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      皖ICP备2021010043号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
</body>
</html>
