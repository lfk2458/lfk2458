<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP｜GET 和 POST 区别？网上多数答案都是错的！</title>
    <link href="/%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C/HTTP%EF%BD%9CGET%20%E5%92%8C%20POST%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%BD%91%E4%B8%8A%E5%A4%9A%E6%95%B0%E7%AD%94%E6%A1%88%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84%EF%BC%81.html"/>
    <url>/%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C/HTTP%EF%BD%9CGET%20%E5%92%8C%20POST%20%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%BD%91%E4%B8%8A%E5%A4%9A%E6%95%B0%E7%AD%94%E6%A1%88%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84%EF%BC%81.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-｜-GET-和-POST-区别？网上多数答案都是错的！"><a href="#HTTP-｜-GET-和-POST-区别？网上多数答案都是错的！" class="headerlink" title="HTTP ｜ GET 和 POST 区别？网上多数答案都是错的！"></a>HTTP ｜ GET 和 POST 区别？网上多数答案都是错的！</h2><p>​<img src="https://upload-images.jianshu.io/upload_images/5219651-7c744cff9d8be1b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="">​</p><blockquote><p>最近在看《HTTP 权威指南》这本书，对 HTTP 协议有了更深一层的了解。</p><p>在我们面试过程中关于 HTTP 协议有两个经典的面试题：</p><ol><li><p>谈谈 HTTP 中 GET 与 POST 的区别。</p></li><li><p>在浏览器中输入 URL 到整个页面显示在用户面前时这个过程中到底发生了什么。</p></li></ol><p>今天我就先谈谈第一个问题。</p></blockquote><p><strong>一、最普遍的答案</strong></p><p>我们在 Google 或百度上搜索这个问题时，得到最多的答案就是如下三点，而这似乎也成为了“标准答案”，其实这个答案有待商榷。</p><ol><li><p>GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 BODY 中。</p></li><li><p>GET 方式提交的数据有长度限制，则 POST 的数据则可以非常大。</p></li><li><p>POST 比 GET 安全，因为数据在地址栏上不可见。</p></li></ol><p><strong>二、“标准答案”其实是错的</strong></p><blockquote><ol><li>GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 BODY 中</li></ol></blockquote><p>GET 和 POST 是由 HTTP 协议定义的。在 HTTP 协议中，Method 和 Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个 Method 与应用层的数据如何传输是没有相互关系的。</p><p>HTTP 没有要求，如果 Method 是 POST 数据就要放在 BODY 中。也没有要求，如果 Method 是 GET，数据（参数）就一定要放在 URL 中而不能放在 BODY 中。</p><p>那么，网上流传甚广的这个说法是从何而来的呢？我在 HTML 标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是 HTML 标准对 HTTP 协议的用法的约定。怎么能当成 GET 和 POST 的区别呢？</p><p>而且，现代的 Web Server 都是支持 GET 中包含 BODY 这样的请求。虽然这种请求不可能从浏览器发出，但是现在的 Web Server 又不是只给浏览器用，已经完全地超出了 HTML 服务器的范畴了。</p><blockquote><ol><li>GET 方式提交的数据有长度限制，则 POST 的数据则可以非常大</li></ol></blockquote><p>先说结论：HTTP 协议对 GET 和 POST 都没有对长度的限制。HTTP 协议明确地指出了，HTTP 头和 Body 都没有长度的要求。</p><p>首先是”GET 方式提交的数据有长度限制”，如果我们使用 GET 通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节 (2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。</p><p>注意这个限制是整个 URL 长度，而不仅仅是你的参数值数据长度。</p><p>POST 也是一样，POST 是没有大小限制的，HTTP 协议规范也没有对 POST 数据进行大小限制，起限制作用的是服务器的处理程序的处理能力。</p><p>当然，我们常说 GET 的 URL 会有长度上的限制这个说法是怎么回事呢？虽然这个不是 GET 和 POST 的本质区别，但是我们也可以说说导致 URL 长度限制的两方面的原因：</p><ol><li><p>浏览器。早期的浏览器会对 URL 长度做限制。而现在的具体限制是怎么样的，我自己没有亲测过，就不复制网上的说法啦。</p></li><li><p>服务器。URL 长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个 M 大小的 URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，告诉服务器 Content-Length 是一个很大的数，然后只给服务器发一点儿数据，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给 URL 长度加限制。但是这个限制是针对所有 HTTP 请求的，与 GET、POST 没有关系。</p></li></ol><blockquote><ol><li>POST 比 GET 安全，因为数据在地址栏上不可见</li></ol></blockquote><p>这个说法其实也是基于上面的 1，2 两点的基础上来说的，我觉得没什么问题，但是需要明白为什么使用 GET 在地址栏上就不安全了，以及还有没有其他原因说明“POST 比 GET 安全”。</p><p>通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻击。</p><p><strong>三、我的理解</strong></p><p>“1. GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 BODY 中”，这个是因为 HTTP 协议用法的约定。并非它们的本身区别。</p><p>“2. GET 方式提交的数据有长度限制，则 POST 的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是 GET 和 POST 本身的区别。</p><p>“3. POST 比 GET 安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是 GET 和 POST 本身的区别。</p><p>虽然这三点不是它们的本身区别，但至少是它们在使用上的区别，所以我在面试这个问题时，如果面试者能够回答上面三点我基本会给个及格分。那么你想不想要更高的分数？</p><p><strong>四、终极区别</strong></p><p>GET 和 POST 最大的区别主要是 GET 请求是幂等性的，POST 请求不是。这个是它们本质区别，上面的只是在使用上的区别。</p><blockquote><p>什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一 URL 的多个请求应该返回同样的结果。</p><p>关于幂等性看我评论上推荐的一篇文章。</p></blockquote><p>正因为它们有这样的区别，所以不应该且不能用 get 请求做数据的增删改这些有副作用的操作。因为 get 请求是幂等的，在网络不好的隧道中会尝试重试。如果用 get 请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用 get 请求去做增操作）。</p><p>你是一位道具师，演员在拍电影时大家都约定俗成在对打时用假抢（无杀伤力），在打靶时用气枪（有杀伤力），而你是个异类的道具师，你在对打时把演员的假抢换成了气枪。..</p><p><strong>五、我的建议</strong></p><p>如果面试官问你这个问题时，我建议你说出上面三点，同时要说明那三点是它们在使用上的区别，当然也要把它们的终极区别给说出来。</p><p>PS：曾经有一个研读了 HTTP 协议的人去一家公司面试，面试官问他这个问题时，他回答“GET 是用于获取数据的，POST 一般用于将数据发给服务器。其他 GET 和 POST 没什么区别”，于是被刷了。</p><p>因为有些面试官心中也只有那一个“标准答案”。</p><hr><p>我每次面试都会问这个问题，你知道怎么回答了吗？</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E9%85%8D%E7%BD%AE.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E9%85%8D%E7%BD%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h1><h2 id="Git-config-的全局配置"><a href="#Git-config-的全局配置" class="headerlink" title="Git config 的全局配置"></a>Git config 的全局配置</h2><p>全局设置有两种方式，<strong>命令方式</strong>  和  <strong>配置文件方式</strong>，两种方式选择任意一种，都可以配置全局 git 项目提交 git 信息的账号及邮箱。</p><h3 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h3><p>在 git 服务器中，任意非  <strong>本地 git repo</strong>  中，使用以下命令配置全局配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;your-username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your-email-address&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h3><p>编辑  <strong>〜/.gitconfig</strong>，其内容与  <strong>.git/config</strong>  文件中的内容相同，即将  <strong>[user]</strong>  部分信息添加至  <strong>〜/.gitconfig</strong>  文件中，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>    name = your-username<br>    email = your-email-address<br></code></pre></td></tr></table></figure><p>保存并退出。任意非  <strong>本地 git repo</strong>  中，在使用以下命令查看是否配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.name<br><br>git config user.email<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>踩坑！用 Git 同时上传代码到 GitHub 和 Coding</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E8%B8%A9%E5%9D%91%EF%BC%81%E7%94%A8%20Git%20%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0%20GitHub%20%E5%92%8C%20Coding.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E8%B8%A9%E5%9D%91%EF%BC%81%E7%94%A8%20Git%20%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0%20GitHub%20%E5%92%8C%20Coding.html</url>
    
    <content type="html"><![CDATA[<p>发现最近网站的访问速度并不理想，因为当时只托管在了 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F">GitHub</a> 上，GitHub 的服务器在国外，所以导致国内访问服务器的时间比较长。</p><p>解决方法就是把网站同时托管在国内的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcoding.net%2F">Coding</a> 上，正好他们也提供了 pages 服务。让国外解析到 GitHub 的服务器上，国内解析到 Coding 的服务器上，这样无论是在国内，还是再国外，网站的访问速度都会大幅提升。</p><p>所以就有了这次的踩坑经历，用 Git 同时管理并 push 到两个远程仓库。</p><p>废话不多说，下面直接上干货。</p><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>先在 Coding 和 GitHub 上创建仓库，为了避免错误，不要初始化 README，license，或者 gitignore 文件</p><p><strong>GitHub</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-5d5c9ed21c7d7af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-4b228404fc055409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p><strong>Coding</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-4572446e7a7d6e89.png" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-7512db0635a81765.png" alt=""></p><p>‍</p><h2 id="进入本地项目"><a href="#进入本地项目" class="headerlink" title="进入本地项目"></a>进入本地项目</h2><p>打开终端，进入项目目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 你的本地项目地址<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-d37b2fb04577e9f1.png" alt=""></p><p>‍</p><h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-c0a9250aa410bac4.png" alt=""></p><p>‍</p><h2 id="删除已关联的名为-origin-的远程库"><a href="#删除已关联的名为-origin-的远程库" class="headerlink" title="删除已关联的名为 origin 的远程库"></a>删除已关联的名为 origin 的远程库</h2><p>使用多个远程库时，要注意 Git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库，首先要删除已关联的名为 origin 的远程库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p>如果输入后显示如下图所示：fatal: No such remote: origin ，说明你本地项目没有已关联的名为 origin 的远程库，那么你可以忽略此步。</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-2c65e0805ade5cb0.png" alt=""></p><p>‍</p><h2 id="配置-Git-用户名和邮箱"><a href="#配置-Git-用户名和邮箱" class="headerlink" title="配置 Git 用户名和邮箱"></a>配置 Git 用户名和邮箱</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name &quot;fengkai.lou&quot;<br><br>git config <span class="hljs-keyword">user</span>.email &quot;loufengkai@qq.com&quot;<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-6e444810e347ae6d.png" alt=""></p><p>‍</p><h2 id="关联-GitHub-远程库"><a href="#关联-GitHub-远程库" class="headerlink" title="关联 GitHub 远程库"></a>关联 GitHub 远程库</h2><p>这里我用的是 SSH 的方式，至于如何管理并配置 SSH，你可以参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.lien.run%2F20190805%2Fmore-ssh">这里</a></p><p>注意，远程库的名称叫 github，不叫 origin 了！</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="language-bash"> github git@github.com:isArtJay/test.git</span><br></code></pre></td></tr></table></figure><p>‍</p><h2 id="关联-Coding-远程库"><a href="#关联-Coding-远程库" class="headerlink" title="关联 Coding 远程库"></a>关联 Coding 远程库</h2><p>同样注意，远程库的名称叫 coding，不叫 origin 了！</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add coding git@e.coding.net:liencn<span class="hljs-regexp">/lien/</span>test.git<br></code></pre></td></tr></table></figure><p>现在，我们用 <code>git remote -v ​</code>​ 查看远程库信息，可以看到两个远程库：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-470c5bc31088fbe1.png" alt=""></p><p>‍</p><h2 id="添加文件到本地仓库"><a href="#添加文件到本地仓库" class="headerlink" title="添加文件到本地仓库"></a>添加文件到本地仓库</h2><p>添加文件到本地仓库，其中 <strong>.</strong> 的意思是本地项目目录中的所有文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><p>‍</p><h2 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h2><p>-m 后的参数是你的提交信息，可以随意填写：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;First commit&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-8af0c43cd00d059d.png" alt=""></p><p>‍</p><h2 id="push-到远程仓库"><a href="#push-到远程仓库" class="headerlink" title="push 到远程仓库"></a>push 到远程仓库</h2><p>如果要 push 到 GitHub，使用命令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> github master<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-eb8cd1e036944079.png" alt=""></p><p>如果要 push 到 Coding，使用命令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> coding master<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-2fe4a0f2be7b1d9c.png" alt=""></p><p>‍</p><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>可以看到我们已经将本地项目推送到了的 GitHub 仓库和 Coding 仓库：</p><p><strong>GitHub</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-b858c1f96a1a9c33.png" alt=""></p><p><strong>Coding</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-362ae9c9b12eef73.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 版思源笔记使用 Dark+ 主题，无法显示“霞鹜文楷等宽”字体的解决方式</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E7%89%88%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8Dark+%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E2%80%9C%E9%9C%9E%E9%B9%9C%E6%96%87%E6%A5%B7%E7%AD%89%E5%AE%BD%E2%80%9D%E5%AD%97%E4%BD%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E7%89%88%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8Dark+%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E2%80%9C%E9%9C%9E%E9%B9%9C%E6%96%87%E6%A5%B7%E7%AD%89%E5%AE%BD%E2%80%9D%E5%AD%97%E4%BD%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<p>在 Docker 版思源笔记中使用 Dark+ 主题时，编辑器的字体与 Dark+ 中主题预览的字体不一致。</p><p>此问题咨询了思源笔记官方得到是回复是“官方暂时不考虑 Docker 版的编辑器暂不考虑支持自定义字体”。</p><p>咨询 Dark+ 主题的制作者得到的回复是“思源笔记官方做了限制”。</p><p>Dark+ 主题的制作者提供了一个解决方案如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.b3-typography</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.b3-typography--default</span>),<br><span class="hljs-selector-class">.protyle-wysiwyg</span>,<br><span class="hljs-selector-class">.protyle-title</span>,<br><span class="hljs-selector-class">.protyle-title__input</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;霞鹜文楷等宽&quot;</span>, <span class="hljs-string">&quot;quote&quot;</span>, <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, <span class="hljs-string">&quot;Luxi Sans&quot;</span>, <span class="hljs-string">&quot;DejaVu Sans&quot;</span>, <span class="hljs-string">&quot;Hiragino Sans GB&quot;</span>, <span class="hljs-string">&quot;Microsoft Yahei&quot;</span>, sans-serif, <span class="hljs-string">&quot;Apple Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-string">&quot;Noto Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Symbol&quot;</span>, <span class="hljs-string">&quot;Android Emoji&quot;</span>, <span class="hljs-string">&quot;EmojiSymbols&quot;</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装 MSSQL</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MSSQL.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MSSQL.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-安装-MSSQL"><a href="#Docker-安装-MSSQL" class="headerlink" title="Docker 安装 MSSQL"></a>Docker 安装 MSSQL</h1><h2 id="群晖安装"><a href="#群晖安装" class="headerlink" title="群晖安装"></a>群晖安装</h2><ol><li>下载 MSSQL 镜像</li></ol><ul><li>由于在群晖 Docker 的注册表中无法搜索到微软官方的镜像，因此这里我们在 SSH 客户端通过 bash 命令来下载镜像。</li><li>首先，在群晖主页 - 控制面板 - 连接性 - 终端机和 SNMP-终端机选项卡中启动 SSH 功能，如下图：<br><img src="https://image.loufengkai.top/siyuan/clipboard_20230208_121940.png" alt="启用群晖的 SSH 功能"></li><li>然后通过 SSH 客户端连接至群晖系统，这里我用的是 Tabby Terminal，然后执行以下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker pull mcr.microsoft.com/mssql/server:2022-latest<br></code></pre></td></tr></table></figure><p>执行结果如下图：<br><img src="https://image.loufengkai.top/siyuan/clipboard_20230208_122254.png" alt="下载 MSSQL 镜像"></p><ul><li>回到群晖主界面-Docker-映像，就可以看到这个镜像了，如下图：<br><img src="https://image.loufengkai.top/siyuan/clipboard_20230208_122603.png" alt="群晖主界面-Docker-映像"></li></ul><ol><li>创建持久化挂载目录并设置目录权限<br>如下图创建目录：<br><img src="https://image.loufengkai.top/siyuan/202302080035215.png" alt="创建目录"><br>并鼠标右键点击 mssqlserver-属性，新增用户权限，这里为了简化，把 mssqlserver 这个目录及子目录的所有权限设置给 EveryOne，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080039350.png" alt="授予权限"></li><li>启动 mcr.microsoft.com/mssql/server:2022-latest 镜像</li></ol><ul><li>从群晖主页-Docker-映像列表中找到 mssql/server，然后点击上面的启动按钮，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080044874.png" alt="创建容器"><br>在启动对话框中输入容器名称、设置资源限制，重启自动启动。</li><li>然后点击“高级设置”按钮增加 2 个环境变量，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080050483.png" alt="设置环境变量"><blockquote><p>ACCEPT_EULA 表示同意微软的许可协议，值必须是 Y。<br>MSSQL_SA_PASSWORD 表示 sa 账户的密码，必须是强安全规则的，大小写字母特殊字符数字切长度大于等于 8</p></blockquote></li><li>点击“保存”按钮，然后点击“下一步”，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080115377.png" alt="保存"><br>这里是进行主机端口与容器端口进行映射。</li><li>点击‘下一步“按钮，如下图：</li><li><img src="https://image.loufengkai.top/siyuan/202302080054885.png" alt="映射端口"><br>点击”添加文件夹“，进行持久化挂载目录映射，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080056913.png" alt="挂载目录映射"></li><li>点击”下一步“，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080056964.png" alt="摘要"></li><li>点击”完成“按钮，容器就会启动，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080057305.png" alt="启动容器"></li></ul><ol><li>在工作电脑访问 Docker 中的 SQL Server</li></ol><ul><li>可以在工作电脑上安装一个 SSMS，启动后，输入连接参数，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080115976.png" alt="输入连接参数"></li><li>点击”连接“，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080116784.png" alt="连接群晖上的 MSSQL"></li><li><p>新建查询，查看一下数据库的版本，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080118909.png" alt="查询"></p></li><li><p>创建一个数据库，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080120450.png" alt="创建数据库"></p></li><li>在群晖 File Station 中查看数据库文件，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080122914.png" alt="查看数据库文件"></li></ul><h2 id="非群晖安装"><a href="#非群晖安装" class="headerlink" title="非群晖安装"></a>非群晖安装</h2><ol><li>从 Microsoft 容器注册表中请求 SQL Server 2022 (16.x) Linux 容器映像。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker pull mcr.microsoft.com/mssql/server:2022-latest<br></code></pre></td></tr></table></figure><ol><li>要使用 Docker 运行 Linux 容器映像，可以从 Bash Shell 或提升的 PowerShell 命令提示符使用以下命令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker run -e <span class="hljs-string">&quot;ACCEPT_EULA=Y&quot;</span> -e <span class="hljs-string">&quot;MSSQL_SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot;</span> \<br>   -p 1433:1433 --name sql1 --hostname sql1 \<br>   -d \<br>   mcr.microsoft.com/mssql/server:2022-latest<br></code></pre></td></tr></table></figure><blockquote><p>密码应符合 SQL Server 默认密码策略，否则容器无法设置 SQL Server，将停止工作。默认情况下，密码必须为至少八个字符且包含以下四种字符中的三种：大写字母、小写字母、十进制数字、符号。</p></blockquote><p>下表对前一个  <code>docker run</code>  示例中的参数进行了说明：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>-e “ACCEPT_EULA=Y”</strong></td><td style="text-align:left">将  <code>ACCEPT_EULA</code>变量设置为任意值，以确认接受最终用户许可协议。SQL Server 映像的必需设置。</td><td></td></tr><tr><td style="text-align:left"><strong>-e “MSSQL_SA_PASSWORD=<a href="&#109;&#97;&#x69;&#108;&#116;&#x6f;&#x3a;&#89;&#111;&#x75;&#x72;&#x53;&#116;&#114;&#x6f;&#x6e;&#103;&#64;&#x50;&#x61;&#115;&#115;&#x77;&#x30;&#x72;&#x64;">&#89;&#111;&#x75;&#x72;&#x53;&#116;&#114;&#x6f;&#x6e;&#103;&#64;&#x50;&#x61;&#115;&#115;&#x77;&#x30;&#x72;&#x64;</a>“</strong></td><td style="text-align:left">指定至少包含 8 个字符且符合  <a href="https://learn.microsoft.com/zh-cn/sql/relational-databases/security/password-policy?view=sql-server-ver16">SQL Server 密码要求</a> 的强密码。SQL Server 映像的必需设置。</td><td></td></tr><tr><td style="text-align:left"><strong>-e “MSSQL<em>COLLATION=&lt;_SQL_Server_collation</em>&gt;”</strong></td><td style="text-align:left">指定自定义 SQL Server 排序规则，而不使用默认值  <code>SQL_Latin1_General_CP1_CI_AS</code>。</td></tr><tr><td style="text-align:left"><strong>-p 1433:1433</strong></td><td style="text-align:left">将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。在此示例中，SQL Server 侦听容器中的 TCP 1433，此容器端口随后会对主机上的 TCP 端口 1433 公开。</td><td>公开。</td></tr><tr><td style="text-align:left"><strong>—name sql1</strong></td><td style="text-align:left">为容器指定一个自定义名称，而不是使用随机生成的名称。如果运行多个容器，则无法重复使用相同的名称。</td><td></td></tr><tr><td style="text-align:left"><strong>—hostname sql1</strong></td><td style="text-align:left">用于显式设置容器主机名。如果未指定主机名，则主机名默认为容器 ID，这是随机生成的系统 GUID。</td><td></td></tr><tr><td style="text-align:left"><strong>-d</strong></td><td style="text-align:left">在后台运行容器（守护程序）。</td></tr><tr><td style="text-align:left"><strong>mcr.microsoft.com/mssql/server:2022-latest</strong></td><td style="text-align:left">SQL Server Linux 容器映像。</td></tr></tbody></table></div><ol><li>要查看 Docker 容器，请使用  <code>docker ps</code>  命令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker ps -a<br></code></pre></td></tr></table></figure><p>应该会看到与下面类似的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CONTAINER ID   IMAGE                                        COMMAND                    CREATED         STATUS         PORTS                                       NAMES<br>d4a1999ef83e   mcr.microsoft.com/mssql/server:2022-latest   <span class="hljs-string">&quot;/opt/mssql/bin/perm...&quot;</span>   2 minutes ago   Up 2 minutes   0.0.0.0:1433-&gt;1433/tcp, :::1433-&gt;1433/tcp   sql1<br></code></pre></td></tr></table></figure><ol><li>更改系统管理员密码<br>SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。创建 SQL Server 容器后，可以通过在容器中运行中运行  <code>echo $MSSQL_SA_PASSWORD</code>  来发现指定的  <code>MSSQL_SA_PASSWORD</code>环境变量。出于安全考虑，请考虑更改 SA 密码。码。</li></ol><ul><li>选择 SA 用户要使用的强密码。</li><li>使用  <code>docker exec</code>运行 sqlcmd，以使用 Transact-SQL 更改密码。以下示例将从用户输入中读取旧密码和新密码。码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker <span class="hljs-built_in">exec</span> -it sql1 /opt/mssql-tools/bin/sqlcmd \<br>-S localhost -U SA \<br> -P <span class="hljs-string">&quot;<span class="hljs-subst">$(read -sp <span class="hljs-string">&quot;Enter current SA password: &quot;</span>; echo <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;REPLY&#125;</span>&quot;</span>)</span>&quot;</span> \<br> -Q <span class="hljs-string">&quot;ALTER LOGIN SA WITH PASSWORD=\&quot;<span class="hljs-subst">$(read -sp <span class="hljs-string">&quot;Enter new SA password: &quot;</span>; echo <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;REPLY&#125;</span>&quot;</span>)</span>\&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dcoker 安装 Cloudreve 网盘</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Dcoker%E5%AE%89%E8%A3%85Cloudreve%E7%BD%91%E7%9B%98.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Dcoker%E5%AE%89%E8%A3%85Cloudreve%E7%BD%91%E7%9B%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="Dcoker-安装-Cloudreve-网盘"><a href="#Dcoker-安装-Cloudreve-网盘" class="headerlink" title="Dcoker 安装 Cloudreve 网盘"></a>Dcoker 安装 Cloudreve 网盘</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>从群晖套件中安装好 Docker</p></li><li><p>创建共享文件夹，比如名称为<code>dokcer</code></p></li><li><p>在 docker 文件夹下创建<code>cloudreve</code>文件夹</p></li><li><p>在<code>cloudreve</code>文件夹下创建<code>config</code>、<code>db</code>、<code>uploads</code>、<code>avatar</code>四个文件夹</p></li><li><p>创建配置文件，放在<code>config</code>目录下面，内容如下：</p></li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>下载 Cloudreve 镜像</li></ol><p>打开 Docker，在注册表中搜索<code>cloudreve</code>，选择第一个<code>cloudreve/cloudreve</code>, 并双击下载<br><img src="https://image.loufengkai.top/siyuan/202302081222160.png" alt=""> 2. 下载完成后，从<code>映像</code>中找到镜像，双击开始安装</p><blockquote><p>容器名称随便填，建议为 cloudreve</p></blockquote><p><img src="https://image.loufengkai.top/siyuan/202302081224952.png" alt=""></p><ol><li><p>点击<code>高级设置</code>，开始设置<code>存储空间</code>、<code>端口设置</code>和<code>环境</code></p></li><li><p><code>存储空间</code>需要挂载 4 个目录</p></li></ol><blockquote><ul><li>uploads 对应下载目录</li><li>db 对应数据库目录</li><li>avatar 对应用户头像目录</li><li>config 对应配置目录</li></ul></blockquote><p><img src="https://image.loufengkai.top/siyuan/202302081227639.png" alt=""></p><ol><li><p>端口保持默认的<code>5212</code>即可，改成其他的也行<br><img src="https://image.loufengkai.top/siyuan/202302081225807.png" alt=""></p></li><li><p>以上配置完成后，点击<code>应用</code>回到创建向导页面，继续点击<code>下一步</code>，勾选<code>向导完成后运行此容器</code>，点击<code>完成</code>即可<br><img src="https://image.loufengkai.top/siyuan/202302081229919.png" alt=""></p></li><li><p>获取初始管理员账号和密码</p></li></ol><p>回到 docker 页面，在<code>容器</code>中找到上面创建好的 cloudreve 容器，双击打开，切换到<code>日志</code>页面，可以看到初始管理员账号和密码<br><img src="https://image.loufengkai.top/siyuan/202302081230461.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装 bitwarden</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85bitwarden.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85bitwarden.html</url>
    
    <content type="html"><![CDATA[<h2 id="Docker-安装-bitwarden"><a href="#Docker-安装-bitwarden" class="headerlink" title="Docker 安装 bitwarden"></a>Docker 安装 bitwarden</h2><p>说明：</p><p>bitwarden 是一款开源密码管理器，其衍生版本 docker 镜像名为 bitwarden_rs。</p><p>bitwarden_rs 项目从 v2.21.0 开始，已更名为 Vaultwarden。</p><p>项目地址：<a href="https://github.com/dani-garcia/vaultwarden">https://github.com/dani-garcia/vaultwarden</a></p><p>Ps：文中会使用到 Portainer-Docker 可视化工具进行操作。</p><h2 id="1-安装-Vaultwarden"><a href="#1-安装-Vaultwarden" class="headerlink" title="1. 安装 Vaultwarden"></a>1. 安装 Vaultwarden</h2><p>docker 拉取 bitwarden 镜像</p><pre><code class="hljs">docker pull vaultwarden/server:latest</code></pre><p>创建 bitwarden 容器，8001 端口</p><pre><code class="hljs">docker run -it -d --name vaultwarden -v /data/vaultwarden/data/:/data/ -p 8001:80  --restart=always  vaultwarden/server:latest</code></pre><p>Portainer 中操作如下：</p><p><img src="https://img2022.cnblogs.com/blog/2224398/202203/2224398-20220303145132517-663623153.png" alt=""></p><p><img src="https://img2022.cnblogs.com/blog/2224398/202203/2224398-20220303145153373-2014990969.png" alt=""></p><h2 id="2-安装-acme-sh，使用-Letsencrypt-颁发-SSL-证书"><a href="#2-安装-acme-sh，使用-Letsencrypt-颁发-SSL-证书" class="headerlink" title="2. 安装 acme.sh，使用 Letsencrypt 颁发 SSL 证书"></a>2. 安装 acme.sh，使用 Letsencrypt 颁发 SSL 证书</h2><h3 id="2-1docker-安装-acme-sh"><a href="#2-1docker-安装-acme-sh" class="headerlink" title="2.1docker 安装 acme.sh"></a>2.1docker 安装 acme.sh</h3><p>acme 官方说明文档：<a href="https://github.com/acmesh-official/acme.sh/wiki/">https://github.com/acmesh-official/acme.sh/wiki/</a></p><pre><code class="hljs">docker pull neilpang/acme.sh</code></pre><h3 id="2-2-注册帐户"><a href="#2-2-注册帐户" class="headerlink" title="2.2 注册帐户"></a>2.2 注册帐户</h3><p>&lt;注意：从 acme.sh v3.0.0 开始，acme.sh 使用 Zerossl 视为默认 ca，您必须先注册帐户（一次），然后才能颁发新证书。&gt;</p><p>ZeroSSL 申请 EAB Credentials for ACME Clients：<a href="https://app.zerossl.com/developer">https://app.zerossl.com/developer</a></p><pre><code class="hljs">docker  run  --rm  -it  -v  &quot;/data/acme.sh/out/&quot;:/acme.sh  neilpang/acme.sh  --register-account  --server zerossl --eab-kid  AxxxxQ --eab-hmac-key  5xxxxQ注册成功后会显示一个 ACCOUNT_THUMBPRINT 和 ZeroSSL-CA--rm 参数表示运行停止后立即删除该容器</code></pre><p>如下图：</p><p><img src="https://img2022.cnblogs.com/blog/2224398/202203/2224398-20220303145206783-395889605.png" alt=""></p><h3 id="2-3-修改默认-CA"><a href="#2-3-修改默认-CA" class="headerlink" title="2.3 修改默认 CA"></a>2.3 修改默认 CA</h3><p>acme.sh 的初始 CA 为 ZeroSSL，如果想使用 letsencrypt，请用以下代码</p><pre><code class="hljs">docker  run  --rm  -it  -v  &quot;/data/acme.sh/out/&quot;:/acme.sh  neilpang/acme.sh  --set-default-ca  --server letsencrypt</code></pre><h3 id="2-4-颁发证书"><a href="#2-4-颁发证书" class="headerlink" title="2.4 颁发证书"></a>2.4 颁发证书</h3><p>Godaddy 申请 API Key Management：<a href="https://developer.godaddy.com/keys">https://developer.godaddy.com/keys</a></p><pre><code class="hljs">docker  run  --rm  -it  -v  &quot;/data/acme.sh/out/&quot;:/acme.sh  -e  GD_Key=&quot;exxxK_3xxxH&quot;  -e  GD_Secret=&quot;Vxxxh&quot;  neilpang/acme.sh  --issue  --dns  dns_gd  -d  example.com  -d  *.example.com--rm 参数表示运行停止后删除该容器，参数 v 表示容器路径映射到本地路径，参数-e 中 GD_Key 和 GD_Secret 表示是 Godaddy 的域名。成功之后，证书会保存在 out 文件夹，也可以指定路径，修改上面第一行 `&quot;/data/acme.sh/out/&quot;`，改为你想要保存的路径即可zerossl 的 eab-kid 和 eab-hmac-key，godaddy 的 GD_Key 和 GD_Secret 有效期不长。有时候出现“docker: invalid reference format.”时，更新上述参数即可。&#39;</code></pre><h3 id="2-5-其他操作"><a href="#2-5-其他操作" class="headerlink" title="2.5 其他操作"></a>2.5 其他操作</h3><pre><code class="hljs">docker run --rm  -it -v &quot;/data/acme.sh/out/&quot;:/acme.sh neilpang/acme.sh --revoke  -d example.com$ acme.sh --renew -d example.com --force</code></pre><h2 id="3-配置-nginx-反向代理"><a href="#3-配置-nginx-反向代理" class="headerlink" title="3. 配置 nginx 反向代理"></a>3. 配置 nginx 反向代理</h2><h3 id="3-1docker-安装-nginx"><a href="#3-1docker-安装-nginx" class="headerlink" title="3.1docker 安装 nginx"></a>3.1docker 安装 nginx</h3><pre><code class="hljs">docker  pull  nginx</code></pre><h3 id="3-2-运行-nginx，把-nginx-容器的端口映射到本地端口，"><a href="#3-2-运行-nginx，把-nginx-容器的端口映射到本地端口，" class="headerlink" title="3.2 运行 nginx，把 nginx 容器的端口映射到本地端口，"></a>3.2 运行 nginx，把 nginx 容器的端口映射到本地端口，</h3><p>把 nginx 容器的目录映射到本地的目录，设置重启策略</p><pre><code class="hljs">docker  run  -it  -d  -v  &quot;/data/nginx/config/&quot;:/config/  -v &quot;/data/nginx/www/html/&quot;:/usr/share/nginx/html/ -v &quot;/data/nginx/download/&quot;:/opt/download/ -p  80:80  -p 443:443  -p  3012:3012  --name nginx  --restart=always  nginx</code></pre><h3 id="3-3-把-acme-sh-生成的证书上传到-nginx-服务目录下"><a href="#3-3-把-acme-sh-生成的证书上传到-nginx-服务目录下" class="headerlink" title="3.3 把 acme.sh 生成的证书上传到 nginx 服务目录下"></a>3.3 把 acme.sh 生成的证书上传到 nginx 服务目录下</h3><p>&lt;因为已把’/config’ 目录目录映射到本地，所以只要复制文件到 ‘/data/nginx/‘ 目录下就可以了&gt;</p><pre><code class="hljs">cd /data/acme.sh/out/example.com/cp  example.com.cer  /data/nginx/example.com.cercp example.com.key  /data/nginx/example.com.key</code></pre><h3 id="3-4-创建-web-conf-文件并上传"><a href="#3-4-创建-web-conf-文件并上传" class="headerlink" title="3.4 创建 web.conf 文件并上传"></a>3.4 创建 web.conf 文件并上传</h3><p>把 web.conf 重名为 example.com.conf（自己的域名），上传到容器内 ‘/etc/nginx/conf.d/‘ 目录下</p><pre><code class="hljs">$ docker ps# 查看容器 ID$ docker cp /data/example.com.conf 容器 ID：/etc/nginx/conf.d/example.com.conf# 方法 2$ mv web.conf /data/nginx/download/web.conf$ docker exec -it nginx /bin/bash$ mv /opt/download/web.conf /etc/nginx/conf.d/example.com.conf</code></pre><p>然后重启 nginx 服务。</p><p>此时就可以访问 <a href="https://example.com/">https://example.com</a> 进入 bitwarden 页面，注册使用。</p><p>创建 web.conf 文件</p><pre><code class="hljs">server    &#123;        listen 80;        server_name example.com;        rewrite ^/(.*) https://$server_name/$1 permanent;    &#125;server    &#123;        listen 443 ssl http2;        server_name example.com;        ssl on;        ssl_certificate /config/example.com.cer;        ssl_certificate_key /config/example.com.key;        ssl_session_timeout 5m;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        ssl_ciphers &quot;EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5&quot;;        ssl_session_cache builtin:1000 shared:SSL:10m;        # ssl_dhparam /etc/nginx/dhparam.pem;        add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;;        add_header X-Frame-Options DENY;        add_header X-Content-Type-Options nosniff;        location / &#123;                proxy_set_header  Host  zheteng.pw;                proxy_pass http://192.168.20.5:8001;                proxy_redirect off;                   proxy_set_header X-Real-IP $remote_addr;                proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;        &#125;        location /notifications/hub &#123;            proxy_pass http://127.0.0.1:3012;            proxy_set_header Upgrade $http_upgrade;            proxy_set_header Connection &quot;upgrade&quot;;          &#125;          location /notifications/hub/negotiate &#123;            proxy_pass http://192.168.20.5:8001;          &#125;    &#125;</code></pre><h2 id="4-certbot-使用"><a href="#4-certbot-使用" class="headerlink" title="4.certbot 使用"></a>4.certbot 使用</h2><h3 id="4-1-安装更新-snap"><a href="#4-1-安装更新-snap" class="headerlink" title="4.1 安装更新 snap"></a>4.1 安装更新 snap</h3><pre><code class="hljs">ubuntu20 自带 snapsudo snap install core; sudo snap refresh core</code></pre><p>4.2 安装 certbot</p><pre><code class="hljs">sudo snap install --classic certbot$ sudo ln -s /snap/bin/certbot /usr/bin/certbot$ sudo certbot --apache$ sudo certbot certonly --apache</code></pre><p>参考链接：</p><p><a href="https://certbot.eff.org/instructions?ws=apache&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=apache&amp;os=ubuntufocal</a></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 语法</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/Markdown%E8%AF%AD%E6%B3%95.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/Markdown%E8%AF%AD%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p><a href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/Markdown">Markdown</a> 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p><p><img src="https://image.loufengkai.top/siyuan/202302081152949.png" alt=""></p><p><a href="http://www.ulyssesapp.com">Ulysses for Mac</a></p><h2 id="一，认识-Markdown"><a href="#一，认识-Markdown" class="headerlink" title="一，认识 Markdown"></a>一，认识 Markdown</h2><p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如 <a href="https://www.jianshu.com/">简书</a>）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 <a href="https://link.jianshu.com/?t=http://www.getcloudapp.com">CloudApp</a> 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 <a href="https://link.jianshu.com/?t=http://te1ee.tumblr.com">Tumblr</a>，也支持 Mou 这类 Markdown 工具的直接上传。</p><h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p><h3 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h3><ul><li>专注你的文字内容而不是排版样式，安心写作。</li><li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li><li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li><li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。</li><li>可读、直观、学习成本低。</li></ul><h3 id="使用-Markdown-的误区"><a href="#使用-Markdown-的误区" class="headerlink" title="使用 Markdown 的误区"></a>使用 Markdown 的误区</h3><p>_We believe that writing is about content, about what you want to say – not about fancy formatting._</p><p>我们坚信写作写的是内容，所思所想，而不是花样格式。<br> — Ulysses for Mac</p><ul><li>Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。</li></ul><p><img src="https://image.loufengkai.top/siyuan/202302081150498.png" alt=""></p><p><a href="[https://github.com/adrai/flowchart.js](https://github.com/adrai/flowchart.js">flowchart.js on Github（使用 Markdown 绘制流程图）</a>&gt;)</p><h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><p><img src="https://image.loufengkai.top/siyuan/202302081150169.png" alt=""></p><p>Mou for Mac</p><ul><li>在 Mac OS X 上，我强烈建议你用 <a href="https://link.jianshu.com/?t=http://mouapp.com">Mou</a> 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题（Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 <a href="https://link.jianshu.com/?t=https://github.com/search?utf8=%E2%9C%93&amp;q=Mou">GitHub</a> 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。</li></ul><p><img src="https://image.loufengkai.top/siyuan/202302081151057.png" alt=""></p><p>Mou 的编写与预览窗口</p><p>如果你从事文字工作，我强烈建议你购买 <a href="https://link.jianshu.com/?t=http://www.ulyssesapp.com">Ulysses for Mac</a>，这款软件入围了苹果 Mac App Store 的 The Best of 2013。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。</p><p><img src="https://image.loufengkai.top/siyuan/202302081151662.png" alt=""></p><p>Mac 上一些 Markdown 编辑器</p><ul><li>由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 <a href="https://link.jianshu.com/?t=http://www.markdownpad.com">MarkdownPad</a> ，另一款叫做 <a href="https://link.jianshu.com/?t=http://code52.org/DownmarkerWPF/">MarkPad</a>。</li><li>iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。</li><li>在 Web 端，我强烈推荐 <a href="https://www.jianshu.com/">简书</a> 这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。</li></ul><p><img src="https://image.loufengkai.top/siyuan/202302081151836.png" alt=""></p><p>简书的编辑预览模式</p><h2 id="二，Markdown-语法的简要规则"><a href="#二，Markdown-语法的简要规则" class="headerlink" title="二，Markdown 语法的简要规则"></a>二，Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><img src="https://image.loufengkai.top/siyuan/202302081151938.png" alt=""></p><p>标题</p><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。</p><p><img src="https://image.loufengkai.top/siyuan/202302081151313.png" alt=""></p><p>无序列表与有序列表</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。</p><p>例如这样</p><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p><p><img src="https://image.loufengkai.top/siyuan/202302081151855.png" alt=""></p><p>引用</p><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 ! 号</p><p>图片为：<img src="" alt=""></p><p>链接为：<a href=""></a></p><p>插入图片的地址需要图床，这里推荐 <a href="https://link.jianshu.com/?t=http://weibotuchuang.sinaapp.com">围脖图床修复计划</a> 与 <a href="https://link.jianshu.com/?t=http://www.getcloudapp.com">CloudApp</a> 的服务，生成 URL 地址即可。</p><p><img src="https://image.loufengkai.top/siyuan/202302081151610.png" alt=""></p><p>URL 与图片</p><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 _包含一段文本就是粗体的语法，用一个_ 包含一段文本就是斜体的语法。</p><p>例如：这里是粗体 这里是斜体</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：</p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><p>这种语法生成的表格如下：</p><p>Tables Are Cool</p><p>col 3 is</p><p>right-aligned</p><p>$1600</p><p>col 2 is</p><p>centered</p><p>$12</p><p>zebra stripes</p><p>are neat</p><p>$1</p><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例：</p><p><img src="https://image.loufengkai.top/siyuan/202302081152655.png" alt=""></p><p>使用 tab 键即可缩进。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 * 号，例如：</p><p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。</p><p><img src="https://image.loufengkai.top/siyuan/202302081152949.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server Management Studio (SSMS,SQL Server 管理工具）一直在加载程序包解决方案</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/SQL%20Server%20Management%20Studio%20(SSMS,SQL%20Server%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7)%20%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/SQL%20Server%20Management%20Studio%20(SSMS,SQL%20Server%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7)%20%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-Server-Management-Studio-SSMS-SQL-Server-管理工具）一直在加载程序包解决方案"><a href="#SQL-Server-Management-Studio-SSMS-SQL-Server-管理工具）一直在加载程序包解决方案" class="headerlink" title="SQL Server Management Studio (SSMS,SQL Server 管理工具）一直在加载程序包解决方案"></a>SQL Server Management Studio (SSMS,SQL Server 管理工具）一直在加载程序包解决方案</h1><p>在卸载 SSMS 管理工具后，重新安装会遇到 一直卡在 “正在加载程序包” 的状态<br><strong>解决方法</strong>就是 手动打开注册表 或者快捷方式 <code>win+r</code> 输入 <code>regedit</code><br>依次找到 <code>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\</code> 目录<br>然后把 Microsoft SQL Server Management Studio 整个目录删除掉 再重新启动 SSMS 安装程序即可</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十进制转成二进制的两种方式</title>
    <link href="/%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html"/>
    <url>/%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html</url>
    
    <content type="html"><![CDATA[<h1 id="十进制转成二进制的两种方式"><a href="#十进制转成二进制的两种方式" class="headerlink" title="十进制转成二进制的两种方式"></a>十进制转成二进制的两种方式</h1><h2 id="第一种：用-2-整除的方式"><a href="#第一种：用-2-整除的方式" class="headerlink" title="第一种：用 2 整除的方式"></a>第一种：用 2 整除的方式</h2><p>用 2 整除十进制整数，得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此重复，直到商为小于 1 时为止，然后把先得到余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，以此排列起来。</p><p>注 1：当一个整数除另一个整数得到整数商而没有余数时，叫做整除。如 2 除 6 得 3，就说 2 能整除 6 或 6 能被 2 整除。</p><p>注 2：除以是被除数在前，除数在后；除是除数在前，被除数在后。如 32÷8=4 可描述为：8 除 32 等于 4，或者 32 除以 8 等于 4。</p><p>以十进制 100 转换为二进制为例：</p><p>100/2=50 余 0；50/2=25 余 0；25/2=12 余 1；12/2=6 余 0；6/2=3 余 0；3/2=1 余 1。以此排列十进制的 100 转换成二进制是：1100100。</p><p>计算如下：</p><p><img src="https://image.loufengkai.top/siyuan/202305080950367.png" alt=""></p><h2 id="第二种：1248-比表法（学名不知道，自己取的）"><a href="#第二种：1248-比表法（学名不知道，自己取的）" class="headerlink" title="第二种：1248 比表法（学名不知道，自己取的）"></a>第二种：1248 比表法（学名不知道，自己取的）</h2><p>对比表如下：</p><p><img src="https://image.loufengkai.top/siyuan/202305080952380.png" alt=""></p><p>以十进制 100 转换为二进制为例：</p><p>从左至右依次开始：100 比 128 小，取 0；100 比 64 大，取 1，剩 36；36 比 32 大，取 1，剩 4；4 比 16 小，取 0；4 比 8 小，取 0；4 不比 4 小，取 1，剩 0；0 比 2 小，取 0；0 比 1 小，取 0。最终得：01100100。</p><p><img src="https://image.loufengkai.top/siyuan/202305080954940.png" alt=""></p><p>得：1100100</p><p>又如十进制 168 转换为二进制：</p><p><img src="https://image.loufengkai.top/siyuan/202305080956394.png" alt=""></p><p>得：10101000</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>相见恨晚！终于有篇文章能把 Git 给讲明白了</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%EF%BC%81%E7%BB%88%E4%BA%8E%E6%9C%89%E7%AF%87%E6%96%87%E7%AB%A0%E8%83%BD%E6%8A%8AGit%E7%BB%99%E8%AE%B2%E6%98%8E%E7%99%BD%E4%BA%86.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E7%9B%B8%E8%A7%81%E6%81%A8%E6%99%9A%EF%BC%81%E7%BB%88%E4%BA%8E%E6%9C%89%E7%AF%87%E6%96%87%E7%AB%A0%E8%83%BD%E6%8A%8AGit%E7%BB%99%E8%AE%B2%E6%98%8E%E7%99%BD%E4%BA%86.html</url>
    
    <content type="html"><![CDATA[<h2 id="相见恨晚！终于有篇文章能把-Git-给讲明白了"><a href="#相见恨晚！终于有篇文章能把-Git-给讲明白了" class="headerlink" title="相见恨晚！终于有篇文章能把 Git 给讲明白了"></a>相见恨晚！终于有篇文章能把 Git 给讲明白了</h2><h1 id="0-本文摘要"><a href="#0-本文摘要" class="headerlink" title="0 本文摘要"></a>0 本文摘要</h1><p>相信大家在日常工作中都会用到 Git，但可能对于刚接触到 Git 的同学们来说这种工具的使用还不是很熟练，或者是对于虽然能够规范使用 Git 来完成日常开发的同学们，但可能对于命令背后的原理或许还是一脸懵逼，因此本文希望用较为简单的语言，能够在 Git 的使用上给大家带来帮助或者能解决大家的部分疑惑。首先第 1 节带大家由浅入深的了解 Git 的一些原理，其次第 2 节具体针对 Git 的常用分支操作 - 合并的两种方式（merge 和 rebase）进行了讨论以及给出了这两种合并方式的使用建议，最后在附录中分类整理了一些关于合并操作的常用命令，方便大家快速查找使用。</p><h1 id="1-关于-Git-的一些基本原理"><a href="#1-关于-Git-的一些基本原理" class="headerlink" title="1 关于 Git 的一些基本原理"></a>1 关于 Git 的一些基本原理</h1><h2 id="1-1-Git-是什么—-版本控制"><a href="#1-1-Git-是什么—-版本控制" class="headerlink" title="1.1 Git 是什么—-版本控制"></a>1.1 Git 是什么—-版本控制</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/632d50e21a90414aab2bde95a9a1a0a5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Git 是一个开源的分布式版本控制系统，可以有效、高速地处理从很小到非常大的项目版本管理。最初的目的是 LinusTorvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>那么什么是“版本控制”呢？我为什么要关心它呢？版本控制是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。简单来说就是用于管理多人协同开发项目的技术。如果在多人进行软件开发时没有使用版本控制，将会引发很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。下面总结了一些使用版本控制的优点：</p><p>● 实现跨区域多人协同开发</p><p>● 追踪和记载一个或者多个文件的历史记录</p><p>● 组织和保护你的源代码和文档</p><p>● 统计工作量</p><p>● 并行开发、提高开发效率</p><p>● 跟踪记录整个软件的开发过程</p><p>● 减轻开发人员的负担，节省时间，同时降低人为错误</p><p>因此，在多人开发中我们必须要使用版本控制，目前诞生了很多版本控制工具（如 Git、SVN、CVS），但是由于 Git 易于学习，占用空间小，性能快如闪电，以及方便的临时区域和多个工作流等特性，使 Git 成为影响力最大且使用最广泛的版本控制工具，下面我们将介绍 Git 的一些基本原理。</p><h2 id="1-2-Git-的工作流程原理"><a href="#1-2-Git-的工作流程原理" class="headerlink" title="1.2 Git 的工作流程原理"></a>1.2 Git 的工作流程原理</h2><h3 id="（1）工作区域"><a href="#（1）工作区域" class="headerlink" title="（1）工作区域"></a>（1）工作区域</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a76b07690db34ff0b2203cd8ab549dce~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>首先来介绍介绍下 Git 的工作区域，分为工作区、暂存区和仓库区，每个区域的转换关系如上图所示。</p><ul><li>工作区（workspace）：就是我们平时本地存放项目代码的地方；</li><li>暂存区（index/stage）：用于临时存放我们的改动，事实上它只是一个文件，保存即将提交到文件列表信息；</li><li>仓库区（Repository）：就是安全存放数据的位置，里面有你提交到所有版本的数据，可分为本地仓库和远程仓库（remote），也称为版本库。</li></ul><h3 id="（2）文件状态"><a href="#（2）文件状态" class="headerlink" title="（2）文件状态"></a>（2）文件状态</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1cc893c62bfa45a5963ac16992d7de42~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Git 中的文件可分为五种状态：</p><ul><li>untrack（未追踪）：未跟踪，此文件在文件夹中，但并没有加入到 git 库，不参与版本控制。通过 git add 状态变为 Staged；</li><li>unmodified（未修改）：文件已经入库，未修改，即版本库中的文件快照内容与文件夹中完全一致。这种类型的文件有两种去处，如果它被修改，而变为 Modified。如果使用 git rm 移出版本库，则成为 Untracked 文件；</li><li>modified（已修改）：已修改表示修改了文件，但还没保存到数据库中；</li><li>staged（已暂存）：已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中；</li><li>committed（已提交）：已提交表示数据已经安全地保存在本地数据库中。</li></ul><p>结合文件的五种状态和三个工作区域的对应关系，引出 Git 的基本工作流程如下：</p><p>（1）在工作区中修改文件 A。</p><p>（2）git add fileA，将更改的部分添加到暂存区。具体过程是：首先，它给 A 文件创建 1 个校验和添加到暂存区中。校验和可以理解为是一个文件的唯一索引，git 通过 SHA-1 这种哈希算法，遍历每一个文件，根据文件内容等信息，为文件创建索引，以后只要根据这个索引，我们就可以取出一个文件中的完整内容。然后，git 对当前的暂存区拍了一张照片，也就是我们所说的快照，并将快照放入版本库。快照里包括什么内容呢？快照里包括我们刚才说的文件索引和文件完整内容（类似于 key-value 的结构）。同时，git 采用内置的 blob 对象来存储这三个文件的快照。</p><p>（3）git commit 来提交更新，找到暂存区的文件，将快照永久性存储到仓库区中。具体过程是：首先，git 用一个内置的 tree 对象，把文件的目录结构保存下来。然后，git 在这个 tree 对象上又包了一层，创建了一个 commit 对象，这个 commit 对象也是我们说的 git 进行版本管理的最终对象。commit 对象里包含了 tree 对象，还包含作者、提交评论等信息。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9934fedb4e314e83b3cf9ee59e31cc9a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="（3）数据存储"><a href="#（3）数据存储" class="headerlink" title="（3）数据存储"></a>（3）数据存储</h3><p>以上我们了解到了 Git 的基本工作流程，那么 Git 是如何存储代码信息的？我们知道，Git 与其它版本控制系统不同的是，保存的不是文件的变化或者差异，而是一系列不同时刻的快照。在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。</p><p>那么上述提到的快照是什么呢？快照就是在执行 git commit 时，对当前暂存区的情况拍摄的一张“照片“，这个照片中涵盖的若干信息将被存放到 git 版本库下。若干信息指的是什么？是文件的索引 + 文件的完整内容（key-value 结构），文件的目录结构，和提交信息，这三者分别用 git 内置的 blob，tree，commit 对象进行存储。</p><ul><li>blob: 在 git 中对应着”内容 (content)”, 约等于一整个文件（不包含文件名和文件 mode);</li><li>tree: 在 git 中对应着”目录 (directory)”, 正如每一个目录中可以存储文件或其他子目录一样，tree 的每一个节点可以是一个 blob, 或者另一个 tree;</li><li>commit: 对应着一次提交，保存着对一个顶层树对象的引用（对应着某个路径下的一份完整的内容） , 以及提交信息（包括父 commit);</li></ul><p>我们可以通过一个目录下的文件及结构来对应得到一组 git 对象，下图为文件/目录与 blob/tree 的对应关系：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/337d71f6d3ee4828832dd7125305a157~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>简单来说，就是我们可以通过 HEAD 文件找到当前 branch, 通过当前 branch 找到一个 commit, 通过一个 commit 找到一个顶层目录对应的 tree 对象，一个 tree 对象又会根据目录下的子目录和文件结构对应地指向一组 tree 对象和 blob 对象。由此，可以得到一个：HEAD(ref) -&gt; branch -&gt; commit -&gt; tree -&gt; tree/blob 的指向图。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/559cabc7a29449708f39c0cdd5aaca2a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>因此，上面的由目录到 git 对象的对应关系可以被简化成：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ff94221938584abfac3ebf1e7b57b6e0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>在提交时，git 会从顶部向下 ([He1oise 校对、] 还是从底部往上）观看每一个 blob 和 tree, 然后复用那些能够复用（没有改变）的对象，创造出一棵局部复用的树，所谓 commit 就指向了这棵树。当然，这里我们不用去考虑说树中的一个节点为什么会有多个父节点，因为虽然我们认为树中的节点总只有一个父节点，但实际使用上如果我们只考虑自顶而下地观察，我们其实只能看到这个节点是否属于某一棵树。</p><p>于是，我们在提交过后，获得了一个 commit 对象，这个 commit 对象会指向其。git 所在的目录为根节点的 tree 对象。因此，我们能通过一个 commit 对象找到一个对应的 tree, 根据一个 tree 对象来递归地找到其子 tree 对象和 blob 对象，因而找到当前路径下的一份完整的内容。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bdd8c3dc059e44beb06894b6aea46340~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>到这里，我们就大概整明白了一个分支是如何对应顶层目录下的所有内容了。更进一步地发散开，我们已知一个 commit 可能有零到多个父 commit, 则可以进一步了解到，在一片 commit 组成的森林里，commit 只是指向某一棵树的指示牌而已。</p><h1 id="2-Git-的分支合并方式浅析"><a href="#2-Git-的分支合并方式浅析" class="headerlink" title="2 Git 的分支合并方式浅析"></a>2 Git 的分支合并方式浅析</h1><h2 id="2-1-分支是什么"><a href="#2-1-分支是什么" class="headerlink" title="2.1 分支是什么"></a>2.1 分支是什么</h2><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/519a822fd4bd4232a1a308e5a08367ee~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Git 的分支，从本质上来说它仅仅是指向提交对象的可变指针。Git 的默认分支名字是 master。在多次提交操作之后，我们其实已经有一个指向最后那个提交对象的 master 分支。master 分支会在每次提交时自动向前移动。下面介绍下关于 Git 分支的一些基本概念：</p><ul><li><p>Head 指针：（1）指向当前所在的本地分支，我们可以看到上图中 Head 指向的是 Master 分支，说明当前是在 Master 分支上；（2）Head 指针随着提交操作自动向前移动</p></li><li><p>分支创建：git branch Dev，会在当前所在的提交对象上创建一个指针。</p></li><li>分支切换：git checkout Dev，这条命令做了两件事（1）将 Head 指针移动到 Dev 分支上（2）将工作目录恢复成 Dev 分支所指向的快照内容。</li><li>分支合并：当我们在 Master 和 Dev 分支各自提交了一次分支后，我们可以看到，提交历史已经产生了分叉，当我们想将 Dev 分支上的修改到 Master 分支上时，我们可以使用 git merge 来完成合并操作。git merge 可以合并一个或者多个分支到你已经检出的分支中，然后它将当前分支指针移动到合并结果上。</li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c8981852250b49ebbb8b027c878bbc72~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="">  </p><h2 id="2-2-分支的合并策略"><a href="#2-2-分支的合并策略" class="headerlink" title="2.2 分支的合并策略"></a>2.2 分支的合并策略</h2><p>我们在上一节中提到，merge 操作可以将两个分支的修改整合到一起。具体来说，git 会尝试通过两个分支的 commit 指针，分别向前追溯，找到这两个 commit 指针在历史上最近的一次共同提交点。Git 有几种不同的方法用来寻找这个共同提交，而这些方法就是所谓的“合并策略”。默认 git 会帮你自动挑选合适的合并策略，也可以通过 git merge -s 策略名字来强指定使用的策略类型。下面我们来介绍一下最常见的几种合并策略：Fast-foward，Recursice，Octopus 等。</p><h3 id="（0）Three-way-merge（三向合并原理）"><a href="#（0）Three-way-merge（三向合并原理）" class="headerlink" title="（0）Three-way-merge（三向合并原理）"></a>（0）Three-way-merge（三向合并原理）</h3><p>在正式介绍 git 的合并策略之前，我们可以先来看下这种几种策略共同会遵循的一个原理：三向合并原理（Three Way Merge），举例一个场景：假设有两个同学在各自的分支上对同一个文件进行修改，如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/648a6bd40f344435a241dc500b87c553~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>这个时候我们需要合并两个分支成一个分支，如果我们只对这两个文件进行对比，那么在代码合并时，只知道这两个文件在第 20 行有差异，却不知道应该采纳谁的版本。如果我知道这个文件的原件“base”，那么通过和“原件”代码的对比就能推算出应该采用谁的版本：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9b00bbbd36514c7ebf10b918b96c8411~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>图示可以看出，B 中的代码和 Base 一样，说明 B 中并没有对这行代码做修改，而 A 中的代码和 Base 不一样，说明 A 在 Base 的基础上对这行代码做了修改，那么 A 和 B 合并应该采用 A 中的内容。当然还有一种情况是三个文件的代码都不相同，这就需要我们自己手动去解决冲突了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3f24744283e04a6aacd57c832da8a3ef~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>从上面的例子可以看出采用 Tree-Way-Merge（也称为三向合并）原理来合并代码有个重要前提是可以找到两份代码的“原件”，而 git 因为记录了文件的提交历史，再通过自身的合并策略就可以找到两个 commit 的公共 commit 是哪个，从而通过比对代码来进行合并。</p><h3 id="（1）Fast-forward-amp-Already-Up-To-Date（退化）"><a href="#（1）Fast-forward-amp-Already-Up-To-Date（退化）" class="headerlink" title="（1）Fast forward &amp; Already Up-To-Date（退化）"></a>（1）Fast forward &amp; Already Up-To-Date（退化）</h3><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9263e1bac39457290f16a0462cc5ea3~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>Fast foward 是最简单的一种合并策略，如图将 feature 分支合并到 dev 分支上，git 只需要将 dev 分支的指向最后一个 commit 节点上。Fast forward 是 git 在合并两个没有分叉的分支时的默认行为，如果你想禁用掉这种行为，明确拥有一次合并的 commit 记录，可以使用 git merge —no-ff 命令来禁用掉。</p><h3 id="（2）Recursive"><a href="#（2）Recursive" class="headerlink" title="（2）Recursive"></a>（2）Recursive</h3><p>Recursive 是 git 中最重要也是最常用的合并策略，简单概述为：通过算法寻找两个分支的最近公共祖先节点，再将找到的公共祖先节点作为 base 节点使用三向合并的策略来进行合并。举个例子：圆圈里的字母为当前 commit 中的内容，当我们要合并 C2，C3 两个节点时，先找到他们的公共祖先节点 C1，接着和节点 C1 的内容进行对比，因为 1 的内容是 A，所以 C3 并没有修改内容，而 C2 将内容改成 B，所以最后的合并结果 C4 的内容也是 B。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3572185127c5465eb974d56fa088a186~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>但是可能有更复杂的情况，出现几个分支相互交叉的情况（Criss-Cross 现象）, 如下图所示，当我们在寻找最近公共祖先时，可以找到两个节点：节点 C2 和节点 C3，根据不同公共祖先，可以分为两种情况：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/66d926d804f144e5adfd043ba167ad7b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>（1）节点 C3 作为 base 节点</p><p>通过三向合并策略合并（base 节点的内容是 A，两个待合并分支节点的内容是 B 和 C）我们是无法得出应该使用哪个节点内容的，需要自己手动解决冲突。</p><p>（2）节点 C2 作为 base 节点</p><p>通过三向合并策略合并（base 节点的内容是 B，两个待合并分支节点的内容是 B 和 C）可以得出应该使用 C 来作为最终结果。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1fb8d0dc60bf4c7d85ded4c92eb90142~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>通过上述分析，我们可以得知正确的合并结果应该是 C，那么 git 要如何保证自己能找到正确的 base 节点，尽可能的减少代码的合并冲突呢？实际上 git 在合并时，如果查找发现满足条件的祖先节点不唯一，那么 git 会首先合并满足条件的祖先节点们，将合并完的结果作为一个虚拟的 base 节点来参与接下来的合并。如上图所示：git 会首先合并节点 C2 和节点 C3，找到他们的公共祖先节点 1，在通过三项合并策略得到一个虚拟的节点 C23，内容是 B，再将节点 C23 作为 base 节点，和节点 5，节点 6 合并，比较完后得出最终版本的内容应该是 C。</p><h3 id="（3）Octopus（复杂化）"><a href="#（3）Octopus（复杂化）" class="headerlink" title="（3）Octopus（复杂化）"></a>（3）Octopus（复杂化）</h3><p>Octopus 策略可以让我们优雅的合并多个分支。前面我们介绍的策略都是针对两个分支的，如果现在有多个分支需要合并，使用 Recursive 策略进行两两合并会产生大量的合并记录：每合并其中两个分支就会产生一个新的记录，过多的合并提交出现在提交历史里会成为一种“杂音“，对提交历史造成不必要的”污染“。Octopus 在合并多个分支时只会生成一个合并记录，这也是 git 合并多个分支的默认策略。如下图：在 dev 分支下执行 git merge feature1 feature2。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03038eabf3e94ab18115a75029850492~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h2 id="2-3-分支的另外一种合并操作：Rebase"><a href="#2-3-分支的另外一种合并操作：Rebase" class="headerlink" title="2.3 分支的另外一种合并操作：Rebase"></a>2.3 分支的另外一种合并操作：Rebase</h2><h3 id="（1）场景举例"><a href="#（1）场景举例" class="headerlink" title="（1）场景举例"></a>（1）场景举例</h3><p>我们举一个实际应用的例子来引出 Rebase 操作，设想两种场景：（1）多人共用一个分支开发，且本地分支落后远程分支，需更新（2）一个分支单人开发，且当前研发分支落后于主干分支，需更新</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1a848a148e4945e68d3031183c785532~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>其实，上述两种情况都可抽象为上图所示，由第（1）种情况来举例，假如有多人在同一个分支上开发，C1、C2 为远端分支的提交，C3、C4 为我们在本地仓库的提交还没有推送到远端，如果这个时候另外一个同学将他的提交记录 C5 推送到了远端，这时，我们再想把我们的本地的提交推送到远端时，就需求有一个更新远程仓库并且合并本地分支的操作，目的是将其它同学提交记录也保留下来。那么如何更新呢？有两种办法：（1）git pull（2）git pull —rebase，我们可以先来看下这两种操作所带来的结果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1f33ba9cef74ac6b069adeca8c2858d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="">    其中，左图为 git pull 的操作后的提交历史，我们可以看到在本地分支多了一次合并记录 C6，这是由于 git pull 等同于 git fetch + git merge 操作，先从远端拉取分支，接着再执行合并操作（如有冲突需解除冲突），因此增加了一次提交记录 C6；</p><p>图 5 为执行 git pull —rebase 操作，可以看到我们本地的提交直接变基到了 C5 后面，而且没有增加提交记录，呈现出一条直线，这是因为 git pull —rebase 这个操作其实可以拆分为 fetch+rebase 操作，先从远端同步分支，接着再执行 rebase 操作。所以说这两个命令其实差别是在拉取分支后是执行了 merge 操作，还是 rebase 操作。</p><h3 id="（2）Rebase-原理"><a href="#（2）Rebase-原理" class="headerlink" title="（2）Rebase 原理"></a>（2）Rebase 原理</h3><p>我们可以看到，经过 merge 更新操作远程此时也变成了非直线形式，且有多了一次 merge 记录，而 rebase 更新操作此时变成了一条直线形式，且没有增加提交记录。目前可以总结下，rebase 有以下特点：</p><p>（1）Rebase 之后会改变提交历史记录，分支不再岔开，而是变成了一条直线；</p><p>（2）rebase 之后如果有冲突，解冲突时需把每次的 commit 都解一遍；</p><p>（3）rebase 之后没有保留 merge 记录，意味着没有保存这步的操作，而 git 的意义不就是保存记录吗？</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5a7b78f8cb4d4b80af6e0baf5e0632d0~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>为什么采用 rebase 方式来完成合并操作会有 merge 有这么多的不同呢？其实所谓的变基 (rebase), 指的就是将提交到某一分支的所有修改在另一分支上再应用一次，也就是想修改移动到另一个分支上。看上去就好像是其 base commit 发生了变化。我们可以从 git 源码上得知，rebase 就是调用了多次 merge。</p><p>我们可以从一个例子上直观表示一下 rebase 每一步都做了什么，如下图所示：在 feature 上 rebase dev 时，git 会以 dev 分支对应的 commit 节点作为起点，将 feature 上 commit 节点”变基“至 dev commit 的后面，并且会创建全新的 commit 节点来替代之前 commit，实际上 rebase 操作可以拆分成一系列的 merge 操作，现在我们看一下 rebase 的过程中 git 所做的事情：首先我们需要以 C1 作为 base 节点，C2 和 C4 进行合并生成新的 C5，然后再将 C5 的 parent 指向 C4。C3 到 C6 转变进行了同样的步骤。因为相比较之前的 commit，新的 commit 的 parent 变了，对应的 hash 值自然也变了。因此我们在 rebase 的时候，当前分支有几个 commit 记录那么 git 就需要进行合并几次。如果当前分支比较”干净“，只有一个 commit 记录的话，那么你 rebase 需要解的冲突其实和 merge 是一样的，区别就是 rebase 不会单独生成一个新的 commit 来记录这次合并。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9cb55dda19314dedb313a740a67f2427~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h2 id="2-4-关于-Merge-和-Rebase-的一些讨论"><a href="#2-4-关于-Merge-和-Rebase-的一些讨论" class="headerlink" title="2.4 关于 Merge 和 Rebase 的一些讨论"></a>2.4 关于 Merge 和 Rebase 的一些讨论</h2><h3 id="（1）Rebase-的一些问题"><a href="#（1）Rebase-的一些问题" class="headerlink" title="（1）Rebase 的一些问题"></a>（1）Rebase 的一些问题</h3><ul><li>Rebase 会修改历史记录</li></ul><p>大家可能都看过 git 文档 (pro-git) 里的经典戒律：Do not rebase commits that exist outside your repository and that people may have based work on. 如果在你的 repo 外，有人基于你的某些 commit 在开发，那么你就不应该对这些 commit 做 rebase. 文档里说得很严重，如果你不遵守这条准则，或者说是戒律，你会被人民仇恨，会被亲友唾弃。之所以整这么严重，是因为 rebase 操作的实质是丢弃一些既有的提交，然后相应地新建一系列变更内容相同但不一样的 commit 对象。如果这个提交在 rebase 前被推到了远端共享，而且其他人也在基于它做开发，那么当他们试图提交的时候，就得做所谓的 remerge 了。不论是 merge 还是 rebase, 合并行为都会发生，并导致有端点 (commit) 被提交。只不过在 rebase 中，合并发生在被依次应用每个差量，伴随着在一个分支中创建来自另一个分支的变更的线性历史而完成。而普通的三路合并则仅仅修改端点本身。</p><ul><li>Rebase 可能会导致一系列错误的提交</li></ul><p>rebase 除了修改历史记录之外，还有更深远的效果：rebase 会导致一系列新的提交。虽然这些提交组合起来，最后会达到相同的最终状态，但中间的提交有新的 SHA-1, 基于新的初始状态，代表不同的差异。因此，相较于 merge, rebase 的典型问题是：它事实上被视为”将源分支上的所有修改逐项地应用到目标分支上”, 就之前提到的：”两种整合方法在分支的最终结果上文件内容与结构上毫无区别”, 但也仅此而已——这些因为逐项应用产生的新提交对应的版本在现实里从来没有存在过，没有人真正生产了这些提交，也没有人能证明它们是可行的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/92ef20d2678c4081bc71abafd102338a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>我们看一个例子：在 commit2 中定义了一个函数，接受数字或字符串类型。在 commit4 中调用了这个函数，传入了一个数字。紧接着由于函数 func 维护的同学通知说从 commit3 以后不兼容数字形式了，需要依赖方做修改 (page/page2). 因此，在 commit5 中，我们添加上了对类型的修正。这个时候去 rebase 代码，将 commit4 和 commit5 迁移成 commit4’和 commit5’, 这个时候，commit5’是完全正确且安全的，但是如果我们 commit5 里有错误，希望回退到 commit4’去，问题就大条了。因为 commit4’事实上没有任何人测试过，也不是开发者特意上传的内容。而且可以看见，在这个例子里，是完全通不过类型系统的检查的。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ee3ab6da61284322886466d1d47b737e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="（2）其它相关场景举例"><a href="#（2）其它相关场景举例" class="headerlink" title="（2）其它相关场景举例"></a>（2）其它相关场景举例</h3><p>我们曾经在团队内部做了一个关于 merge 和 rebase 合理使用的调查问卷，有一个建议是希望能够从二者的原理出发，case by case 来分析场景和规避途径，下面列出了一些作者本人或同事们在实际开发中遇到的一些问题场景：</p><h4 id="场景-1：谨慎使用-force-push"><a href="#场景-1：谨慎使用-force-push" class="headerlink" title="场景 1：谨慎使用 force push"></a>场景 1：谨慎使用 force push</h4><p>首先来分享下团队内部曾经在 git 上踩过的坑：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88f90afd865a4c16b6804d17913d433d~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>如上图所示，A 同学和 B 同学共用一个研发分支，B 同学已经提交了两次 commit 并推送到了远端。之后，A 同学也已经开发完成，我们可以看到 A 同学的本地仓库分支已经落后于远端，理应先从远端更新分支，再推送到远端。但是 A 同学没有这么做，如下图所示，而是直接 force push 了上去，就导致了下面这种情况，B 同学的 C3、C4 提交记录被“丢弃”掉了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/42a48df64ab64a7a9498838ac9886bc1~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>此时的补救的方法可以是：B 同学更新远端分支（git pull 或 git pull —rebase），再提交上去，提交历史变为下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7530ec588e424b70b003b5f162b13ac9~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>那么我们应该如何避免这个问题呢：</p><p>（1）提交代码时谨慎使用 force push，建议使用 push（原因：如果我们使用 push 推送时，本地分支落后远端时会有提示）</p><p>（2）A 正确提交方法：先更新本地分支，再推送到远端。</p><p>我们如何更新本地分支：两种方法 merge 或 rebase，下面是两种命令更新后的分支示意图</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f660cd1198334089b5dc401c2e7a4f6a~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>我们可以看到，采用 merge 更新的方式，多了一条合并记录 C6，而 rebase 则是直接把记录从 C5 变更到了 C4’提交的后面且没有多一次的提交记录。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/89432a3f616f4b47bd2f2fcc9f6c30e2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="场景-2：rebase-解冲突"><a href="#场景-2：rebase-解冲突" class="headerlink" title="场景 2：rebase 解冲突"></a>场景 2：rebase 解冲突</h4><p>我们知道，在采用 rebase 方式更新代码时，如果有冲突 解冲突时需把每次的 commit 都解一遍。我们设想这样一种场景，feature 分支上共有三次提交，我们在解决冲突 1 和冲突 2 时如果包含了第三次提交的全部变动内容，我们在推代码后会神奇的发现 C5 记录不见了，这是因为 rebase 合并的实质是丢弃掉原有的提交，而另创建与原提交记录“相似”的提交，通过上述方式解冲突后，新的 C5’已经没有任何新的改动，所以 C5 会被“丢弃掉”。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2de9df7b331a41a595a205566704c811~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h4 id="场景-3：merge-和-rebase-的提交历史差异"><a href="#场景-3：merge-和-rebase-的提交历史差异" class="headerlink" title="场景 3：merge 和 rebase 的提交历史差异"></a>场景 3：merge 和 rebase 的提交历史差异</h4><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b138e1f72bb5405ca3aa7acded22aadc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><p>我们可以直观看到，经过 rebase 更新操作提交历史变成了一条直线形式，而经过 merge 更新操作远程的提交历史为非直线形式，且因为更新（而不是合并）多了一次 merge 记录。但是 rebase 也有很多缺点：</p><p>（1）rebase 之后 如果有冲突 解冲突时需把每次的 commit 都解一遍。</p><p>（2）rebase 之后没有保留 merge 记录，意味着没有保存这步的操作，而 git 的意义不就是保存记录吗？</p><p>但是如果我们换一种思路考虑，我们在本地分支中使用 rebase 来更新，是为了让我们的本地提交记录更加清晰可读。（当然，rebase 不只用来合并 master 的改动，还可以在协同开发时 rebase 队友的改动）而主分支中使用 merge 来把 feature 分支的改动合并进来，是为了保留分支信息。那么如何合适的使用 rebase 和 merge 呢？假如全使用 merge 就会导致提交历史繁复交叉，错综复杂。如果全使用 rebase 就会让你的 commits history 变成一条光秃秃的直线。因此，一个好的 commits history，应该是这样的，有合并记录且分支不交错：</p><pre><code class="hljs">*   e2e6451 (HEAD -&gt; master) feture-c finished|\| * 516fc18 C.2| * 09112f5 C.1|/*   c6667ab feture-a finished|\| * e64c4b6 A.2| * 6058323 A.1|/*   2b24281 feture-b finished复制代码</code></pre><p>而不应该是这样的，分支交错，看起来很混乱：</p><pre><code class="hljs">*   9f0c13b (HEAD -&gt; master) feture-c finished|\| * 55be61c C.2| *   e18b5c5 merge master| |\| |/|/|* |   ee549c2 feture-a finished|\ \| * | 51f2126 A.3| * |   72118e2 merge master| |\ \| |/ /|/| |* | |   6cb16a0 feture-b finished|\ \ \| * | | 7b27b77 B.3| * | | 3aac8a2 B.2| * | | 2259a21 B.1|/ / /| * | 785fab7 A.2| * | 2b2b664 A.1|/ /| * bf9e77f C.1|/* 188abf9 init复制代码</code></pre><p>也不应该是这样的，完全呈一条直线，没有任何的合并记录：</p><pre><code class="hljs">* b8902ed (HEAD -&gt; master) C.2* a4d4e33 C.1* 7e63b80 A.3* 760224c A.2* 84b2500 A.1* cb4c4cb B.3* 2ea8f0d B.2* df97f39 B.1* 838f514 init复制代码</code></pre><h3 id="（3）Merge-和-Rebase-的对比以及使用建议"><a href="#（3）Merge-和-Rebase-的对比以及使用建议" class="headerlink" title="（3）Merge 和 Rebase 的对比以及使用建议"></a>（3）Merge 和 Rebase 的对比以及使用建议</h3><p>我们通过上述例子得知，rebase 和 merge 不是二选一的关系，要协同使用。当开发只属于自己的分支时尽量使用 rebase，减少无用的 commit 合到主分支里，多人合作时尽量使用 merge，一方面减少冲突，另一个方面也让每个人的提交有迹可循。按照上述思路来说，我们按照如下规则可以合理使用 rebase 和 merge 操作：</p><p>（1）如果我们只注重于更新操作时，rebase 操作可能会更好些，因为没必要多生成一个除了开发外的 merge 记录，也可以让我们的本地提交记录清晰可读。</p><p>（2）当我们要把研发分支合入到主干时，我们更注重的是合并的操作，保留合并的记录，这个时候用 merge 会好些。</p><div class="table-container"><table><thead><tr><th></th><th>merge</th><th>rebase</th></tr></thead><tbody><tr><td>- 原理</td><td>三路合并</td><td>多次 merge</td></tr><tr><td>- 对历史的看法</td><td>“提交”的历史</td><td>“变更”的历史</td></tr><tr><td>- 对历史的态度</td><td>我们应当保留每一次提交的现场，不应该对其做修改。</td><td>我们应当使变更足够明晰，每一次变更的内容和在提交链上的位置应当能体现出它的用途何目的。</td></tr><tr><td>- 优点/缺点：</td><td></td><td></td></tr><tr><td>（1）是否保留合并记录</td><td>保留合并记录✅</td><td>不会保留合并记录</td></tr><tr><td>（2）历史提交记录</td><td>分支交错</td><td>提交记录呈直线型更清爽</td></tr><tr><td>（3）更新代码提交记录</td><td>更新代码时会增加一条合并记录</td><td>更新代码时不会增加合并记录✅</td></tr><tr><td>（4）解冲突</td><td>合并代码有冲突时，只需解决一次✅</td><td>每个 commit 都需要分别解冲突</td></tr><tr><td>- 适用场景</td><td></td><td></td></tr><tr><td>（1）feature 分支合入主干</td><td>保留合并记录✅</td><td></td></tr><tr><td>（2）更新代码</td><td>落后主干提交过多时预计冲突较多✅</td><td>更新代码时，且预计冲突不多✅</td></tr></tbody></table></div><h1 id="附录-Git-合并常用命令汇总整理"><a href="#附录-Git-合并常用命令汇总整理" class="headerlink" title="附录 Git 合并常用命令汇总整理"></a>附录 Git 合并常用命令汇总整理</h1><p>假设当前在 feature 分支，公共开发分支为 feature，示意图如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7339b3b51c25448194967744b77c1d99~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt=""></p><h3 id="（1）merge"><a href="#（1）merge" class="headerlink" title="（1）merge"></a>（1）merge</h3><pre><code class="hljs"># feature 分支与 dev 分支合并git merge dev # 禁用自动提交git merge --no-commit dev # 禁用快进合并（保留 merge 记录）git merge --no-ff dev# 将 dev 分支的 commit 压缩成一个再合并git merge --squash dev# 指定合并策略（如 ours、subtree，默认为 recursive 和 octopus）git merge -s &lt;strategy&gt; dev# 显示详细的合并结果信息git merge -v dev# 显示合并的进度信息（不显示--no-progress）git merge -progress dev# 创建合并节点时的提交信息git merge -m &quot;&quot; dev# 合并冲突git merge --continue# 抛弃当前合并冲突的处理过程并尝试重建合并前的状态git merge --abort复制代码</code></pre><h3 id="（2）rebase"><a href="#（2）rebase" class="headerlink" title="（2）rebase"></a>（2）rebase</h3><pre><code class="hljs"># 将 feature 分支变基到 dev 分支上 git rebase dev# 交互式修改或合并 commit 记录，详细使用可见 https://www.jianshu.com/p/4a8f4af4e803git rebase -i [startpoint]  [endpoint]# 拉取远程分支后采用 rebase 方式合并代码git pull --rebase# 合并冲突git rebase --continue# 将 feature 分支从 feature0 分支变基到到 mastergit rebase --onto master feature0# 放弃此次 rebasegit rebase --abort复制代码</code></pre><h3 id="（3）cherry-pick"><a href="#（3）cherry-pick" class="headerlink" title="（3）cherry-pick"></a>（3）cherry-pick</h3><pre><code class="hljs"># 把其他分支的某一个 commit 合入到当前分支git cherry-pick &lt;commit id&gt; # 合并中有冲突，解决完后需要执行下面命令git cherry-pick --continue复制代码</code></pre>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装 MySQL</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MySQL.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MySQL.html</url>
    
    <content type="html"><![CDATA[<ol><li>下载 MySQL 镜像<br><img src="https://image.loufengkai.top/siyuan/202302182219354.png" alt="下载 MySQL 镜像"></li><li>准备映射目录<br>群晖目录下自己选择个地方创建这三个目录，分别用于存储配置文件、数据、错误日志。在创建容器时会用到它们并给对应的映射关系<br><img src="https://image.loufengkai.top/siyuan/202302182221314.png" alt="添加三个映射目录"></li><li>创建容器</li></ol><ul><li>双击镜像列表 mysql 开始创建<br><img src="https://image.loufengkai.top/siyuan/202302182223376.png" alt="开始创建"></li><li>在变量中添加“MYSQL_ROOT_PASSWORD”变量，值为密码<br><img src="https://image.loufengkai.top/siyuan/202302182224242.png" alt="添加“MYSQL_ROOT_PASSWORD”变量"></li><li>添加端口映射<br><img src="https://image.loufengkai.top/siyuan/202302182226276.png" alt="端口映射"></li><li>添加文件夹映射<br><img src="https://image.loufengkai.top/siyuan/202302182227602.png" alt="文件夹映射"></li></ul><ol><li>启动容器<br><img src="https://image.loufengkai.top/siyuan/202302182228878.png" alt="启动 MySQL 容器"></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>百妖谱</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%99%BE%E5%A6%96%E8%B0%B1%EF%BC%88%E5%90%8C%E5%90%8D%E5%8A%A8%E6%BC%AB%E5%8E%9F%E8%91%97%EF%BC%89.html"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%99%BE%E5%A6%96%E8%B0%B1%EF%BC%88%E5%90%8C%E5%90%8D%E5%8A%A8%E6%BC%AB%E5%8E%9F%E8%91%97%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<p><center><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/395/32458395/t9_32458395.jpg" width="180"> </center></p><p><center><font size=4>《百妖谱（同名动漫原著）》</font></center></p><p><center><font color='#6e6e6e' size=2>作者：裟椤双树 </font></center></p><p><center><font color='#6e6e6e' size=2>出版社：长江出版社</font></center></p><p><center><font color='#6e6e6e' size=2>出版日期：2016-12</font></center></p><p><center><font color='#6e6e6e' size=2>ISBN：9787549247653</font></center><br>📖 33 条书摘：</p><hr><h3 id="漱金-1"><a href="#漱金-1" class="headerlink" title="漱金 (1)"></a>漱金 (1)</h3><p>‍一个人真正开心的时候，笑容会发光的。</p><font color='#6e6e6e' size=2> 2021-09-08 08:38:23</font><hr><h3 id="漱金-5"><a href="#漱金-5" class="headerlink" title="漱金 (5)"></a>漱金 (5)</h3><p>‍能在活着的时候，快乐地活着，比什么都要紧。</p><font color='#6e6e6e' size=2> 2021-09-08 08:59:03</font><hr><h3 id="漱金-6"><a href="#漱金-6" class="headerlink" title="漱金 (6)"></a>漱金 (6)</h3><p>‍死了就啥都没有了，必须得活着呀！</p><font color='#6e6e6e' size=2> 2021-09-08 09:01:09</font><hr><h3 id="庆忌-1"><a href="#庆忌-1" class="headerlink" title="庆忌 (1)"></a>庆忌 (1)</h3><p>‍此一生，你未取我性命，我未负你承诺，无憾。</p><font color='#6e6e6e' size=2> 2021-09-08 19:32:53</font><hr><h3 id="庆忌-3"><a href="#庆忌-3" class="headerlink" title="庆忌 (3)"></a>庆忌 (3)</h3><p>‍任何时候，只要你跟我讲一声，千山万水我都回来。</p><font color='#6e6e6e' size=2> 2021-09-08 19:36:38</font><hr><p>‍留下与远行，后者更容易让她幸福。</p><font color='#6e6e6e' size=2> 2021-09-08 19:37:13</font><hr><p>‍“好山好水总得持续多年，方有灵气集聚，积到足够的量，才会有我出世，然后我就像一条没有实体的鱼，在镜花泽下游来游去，没人喊我名字的话，我就得一直这样游下去，若有朝一日此处山水有变，灵气受损，没有实体支撑的我也会随之消失。所以呀，你是来得刚刚好，没有太早也没有太晚。”</p><font color='#6e6e6e' size=2> 2021-09-08 19:38:50</font><hr><h3 id="庆忌-4"><a href="#庆忌-4" class="headerlink" title="庆忌 (4)"></a>庆忌 (4)</h3><p>‍岸边与水面，热闹跟寂寞也只差一步罢了</p><font color='#6e6e6e' size=2> 2021-09-08 19:39:41</font><hr><p>‍我走，他回来便找不到我了。</p><font color='#6e6e6e' size=2> 2021-09-08 19:40:43</font><hr><h3 id="蜉蝣-3"><a href="#蜉蝣-3" class="headerlink" title="蜉蝣 (3)"></a>蜉蝣 (3)</h3><p>‍在山里生活，要跟天斗，出了深山，就要跟人斗，他们不怕天灾，怕人祸。</p><font color='#6e6e6e' size=2> 2021-09-08 19:55:54</font><hr><p>‍红尘滚滚，江河万里，从此只得他一人。</p><font color='#6e6e6e' size=2> 2021-09-08 19:56:23</font><hr><h3 id="乖龙-1"><a href="#乖龙-1" class="headerlink" title="乖龙 (1)"></a>乖龙 (1)</h3><p>‍我们总是习惯于对自己无条件宽容</p><font color='#6e6e6e' size=2> 2021-09-08 20:09:44</font><hr><h3 id="乖龙-2"><a href="#乖龙-2" class="headerlink" title="乖龙 (2)"></a>乖龙 (2)</h3><p>‍我的存在不是为了让你们喜欢，是为了让你们敬畏。</p><font color='#6e6e6e' size=2> 2021-09-08 20:13:47</font><hr><h3 id="乖龙-3"><a href="#乖龙-3" class="headerlink" title="乖龙 (3)"></a>乖龙 (3)</h3><p>‍世上没有谁是多余的，都是有用的。</p><font color='#6e6e6e' size=2> 2021-09-08 20:18:20</font><hr><h3 id="腾根-1"><a href="#腾根-1" class="headerlink" title="腾根 (1)"></a>腾根 (1)</h3><p>‍既然能遇见个让你不想离开的人，就留下吧。</p><font color='#6e6e6e' size=2> 2021-09-09 08:33:47</font><hr><h3 id="腾根-2"><a href="#腾根-2" class="headerlink" title="腾根 (2)"></a>腾根 (2)</h3><p>‍世间任何一种关系，不都得你情我愿才可长久么？”</p><font color='#6e6e6e' size=2> 2021-09-09 08:37:02</font><hr><h3 id="腾根-5"><a href="#腾根-5" class="headerlink" title="腾根 (5)"></a>腾根 (5)</h3><p>‍不想留下的人，是怎么也留不下的。</p><font color='#6e6e6e' size=2> 2021-09-09 08:47:20</font><hr><h3 id="应声-5"><a href="#应声-5" class="headerlink" title="应声 (5)"></a>应声 (5)</h3><p>‍泥地之上，只得一句话——何必低到尘埃里。</p><font color='#6e6e6e' size=2> 2021-09-09 09:09:27</font><hr><h3 id="媪姬-4"><a href="#媪姬-4" class="headerlink" title="媪姬 (4)"></a>媪姬 (4)</h3><p>‍真正让人没力气的不是疾病，是绝望的心情</p><font color='#6e6e6e' size=2> 2021-09-09 19:05:20</font><hr><h3 id="照海-1"><a href="#照海-1" class="headerlink" title="照海 (1)"></a>照海 (1)</h3><p>‍一生一人一条路</p><font color='#6e6e6e' size=2> 2021-09-09 19:06:53</font><hr><h3 id="照海-6"><a href="#照海-6" class="headerlink" title="照海 (6)"></a>照海 (6)</h3><p>‍“她总是一个人，却装得好热闹的样子。我在的话，她才不会那么寂寞吧。”</p><font color='#6e6e6e' size=2> 2021-09-09 19:14:26</font><hr><h3 id="照海-8"><a href="#照海-8" class="headerlink" title="照海 (8)"></a>照海 (8)</h3><p>‍我没有朋友，是因为我太强，你没有朋友，是因为你太弱。</p><font color='#6e6e6e' size=2> 2021-09-09 19:19:57</font><hr><p>‍妒忌是比任何妖怪都可怕的妖怪。</p><font color='#6e6e6e' size=2> 2021-09-09 19:20:46</font><hr><h3 id="照海-11"><a href="#照海-11" class="headerlink" title="照海 (11)"></a>照海 (11)</h3><p>‍人各有命，何时相遇，何时分离，没必要强求。</p><font color='#6e6e6e' size=2> 2021-09-09 19:28:05</font><hr><p>‍你越是想找一个东西，越找不着，你不找了吧，它可能自己就跳出来了。</p><font color='#6e6e6e' size=2> 2021-09-09 19:30:56</font><hr><p>‍一生一人一条路，给了最爱的人，也不算遗憾。</p><font color='#6e6e6e' size=2> 2021-09-09 19:31:35</font><hr><h3 id="非非-1"><a href="#非非-1" class="headerlink" title="非非 (1)"></a>非非 (1)</h3><p>‍“善哉善哉，昨之我非今之我，顿悟在一念之间。”</p><font color='#6e6e6e' size=2> 2021-09-10 08:28:35</font><hr><h3 id="非非-4"><a href="#非非-4" class="headerlink" title="非非 (4)"></a>非非 (4)</h3><p>‍能掠夺的东西越多，就越不像人了。</p><font color='#6e6e6e' size=2> 2021-09-10 08:37:27</font><hr><h3 id="龙雀-1"><a href="#龙雀-1" class="headerlink" title="龙雀 (1)"></a>龙雀 (1)</h3><p>‍可我总是忘不了跟他们在一起的日子，他们的青春，所有的悲欢苦乐，好像也变成了我的。</p><font color='#6e6e6e' size=2> 2021-09-10 18:44:46</font><hr><h3 id="龙雀-6"><a href="#龙雀-6" class="headerlink" title="龙雀 (6)"></a>龙雀 (6)</h3><p>‍这世上多数的相遇都很容易，但不说再见的陪伴却艰难许多，既然碰上了，以后还是在一起吧。</p><font color='#6e6e6e' size=2> 2021-09-10 18:57:27</font><hr><h3 id="傒囊-1"><a href="#傒囊-1" class="headerlink" title="傒囊 (1)"></a>傒囊 (1)</h3><p>‍有的家伙善忘，年少时的热血到底被岁月浇成了洗锅水。　　有的家伙太蠢，别人一丁点好，便记了一辈子。</p><font color='#6e6e6e' size=2> 2021-09-10 19:00:25</font><hr><h3 id="暗刀-5"><a href="#暗刀-5" class="headerlink" title="暗刀 (5)"></a>暗刀 (5)</h3><p>‍但命运就是刀啊，你永远不知道它会落到哪里，把你的人生切割成什么鬼样子。</p><font color='#6e6e6e' size=2> 2021-09-10 19:28:44</font><hr><h3 id="百知-1"><a href="#百知-1" class="headerlink" title="百知 (1)"></a>百知 (1)</h3><p>‍最孤独的人才能走到最高的位置。</p><font color='#6e6e6e' size=2> 2021-09-13 13:37:48</font>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>暗恋：橘生淮南</title>
    <link href="/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9A%97%E6%81%8B%EF%BC%9A%E6%A9%98%E7%94%9F%E6%B7%AE%E5%8D%97%EF%BC%88%E5%85%A8%E9%9B%86%EF%BC%89.html"/>
    <url>/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%9A%97%E6%81%8B%EF%BC%9A%E6%A9%98%E7%94%9F%E6%B7%AE%E5%8D%97%EF%BC%88%E5%85%A8%E9%9B%86%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<div><center><img src="https://wfqqreader-1252317822.image.myqcloud.com/cover/779/35279779/t9_35279779.jpg" width="180"> </center><center><font size=4>《暗恋：橘生淮南（全集）》</font></center><center><font color='#6e6e6e' size=2>作者：八月长安 </font></center><center><font color='#6e6e6e' size=2>出版社：北京联合出版公司</font></center><center><font color='#6e6e6e' size=2>出版日期：2022-6</font></center><center><font color='#6e6e6e' size=2>ISBN：9787559641120</font></center>📖 144 条书摘：</div><hr><h3 id="心魔"><a href="#心魔" class="headerlink" title="心魔"></a>心魔</h3><p>‍勤劳只是因为对脏乱的忍受能力低于他人，她忍不过百丽，只能干活儿。</p><font color='#6e6e6e' size=2> 2022-02-15 08:28:33</font><hr><p>‍因为你只待天命，不尽人事。</p><font color='#6e6e6e' size=2> 2022-02-15 08:28:47</font><hr><p>‍洛枳并不相信命运。她怕自己信了天灾，就忘了人祸。因为人祸是可以憎恨和对抗的，而天意不可违。人一旦相信了命运，还能有什么指望？</p><font color='#6e6e6e' size=2> 2022-02-15 08:28:56</font><hr><p>‍上帝动动小指头，一个人的命运就能急转直下。至于上帝为什么会动小指……也许只是觉得痒。</p><font color='#6e6e6e' size=2> 2022-02-15 08:30:25</font><hr><p>‍毕竟，已经不再是那个用一条明黄色吊带裙就能降伏心魔的年纪了。</p><font color='#6e6e6e' size=2> 2022-02-15 08:30:31</font><hr><h3 id="岁月静好"><a href="#岁月静好" class="headerlink" title="岁月静好"></a>岁月静好</h3><p>‍永远伤心，却永不死心。</p><font color='#6e6e6e' size=2> 2022-02-15 08:30:37</font><hr><p>‍女人最重要的是保持适度的柔弱和适度的坚强，要见好就收，不能做出被人鄙视的举动。</p><font color='#6e6e6e' size=2> 2022-02-15 08:31:08</font><hr><h3 id="也算是圆梦"><a href="#也算是圆梦" class="headerlink" title="也算是圆梦"></a>也算是圆梦</h3><p>‍她最善于伪装的就是真诚。</p><font color='#6e6e6e' size=2> 2022-02-15 08:35:52</font><hr><p>‍难道真是一场“我爱你但与你无关”的戏码？　　洛枳一直觉得这是一句文艺而高明的借口，挽回了包括她在内的无数人的面子。</p><font color='#6e6e6e' size=2> 2022-02-15 08:37:13</font><hr><h3 id="凭什么甘心"><a href="#凭什么甘心" class="headerlink" title="凭什么甘心"></a>凭什么甘心</h3><p>‍上帝明目张胆地不公平，但凡人保留偏执的权利。</p><font color='#6e6e6e' size=2> 2022-02-15 08:40:35</font><hr><p>‍世界上总有那么一种人，对于庸庸碌碌的普通人来说，他们的存在简直是一种讽刺。</p><font color='#6e6e6e' size=2> 2022-02-15 08:41:01</font><hr><h3 id="我最希望看到的"><a href="#我最希望看到的" class="headerlink" title="我最希望看到的"></a>我最希望看到的</h3><p>‍　　在忌妒的人眼中，幸福不在于得到，而在于别人得不到。</p><font color='#6e6e6e' size=2> 2022-02-15 08:42:14</font><hr><h3 id="弱水三千，任你泼"><a href="#弱水三千，任你泼" class="headerlink" title="弱水三千，任你泼"></a>弱水三千，任你泼</h3><p>‍好像一停下来，沉默就会把感情吞噬。</p><font color='#6e6e6e' size=2> 2022-02-15 08:52:42</font><hr><h3 id="一视同仁的路人甲"><a href="#一视同仁的路人甲" class="headerlink" title="一视同仁的路人甲"></a>一视同仁的路人甲</h3><p>‍那些胡言乱语，重点在于写信人自己心里舒坦，回不回也许并不重要。</p><font color='#6e6e6e' size=2> 2022-02-15 08:56:17</font><hr><h3 id="艳遇猝不及防"><a href="#艳遇猝不及防" class="headerlink" title="艳遇猝不及防"></a>艳遇猝不及防</h3><p>‍他从来不曾回过头。她亦步亦趋的高中三年，他从来不曾这样没有原因地回过头。</p><font color='#6e6e6e' size=2> 2022-02-15 09:01:40</font><hr><h3 id="空欢喜"><a href="#空欢喜" class="headerlink" title="空欢喜"></a>空欢喜</h3><p>‍所以平常无聊一点儿，今天才会觉得开心。人这一辈子，大部分时间都是无聊的。”</p><font color='#6e6e6e' size=2> 2022-02-15 09:03:38</font><hr><p>‍他们中间隔着两个孩子，站得很远，远得好像刚刚被荡到空中时紧握的双手并不长在他们身上。</p><font color='#6e6e6e' size=2> 2022-02-15 09:04:08</font><hr><p>‍人和人之间的气氛仿佛是世界上最脆弱的东西，轻轻一拉扯就会变形走样。</p><font color='#6e6e6e' size=2> 2022-02-15 09:04:12</font><hr><p>‍谢谢你，赠我一大筐空欢喜。</p><font color='#6e6e6e' size=2> 2022-02-15 09:06:23</font><hr><h3 id="鸡同鸭讲"><a href="#鸡同鸭讲" class="headerlink" title="鸡同鸭讲"></a>鸡同鸭讲</h3><p>‍只是她从一开始就仰视他，有些姿势中掩藏着不容易发现的卑微和愤怒。她努力挺拔地站直，努力地朝高处走，却仍然是仰着头看他。</p><font color='#6e6e6e' size=2> 2022-02-15 09:07:17</font><hr><p>‍或者只是想唤醒她。仿佛她醒了，另一个人也会看得通透些似的。</p><font color='#6e6e6e' size=2> 2022-02-15 09:09:46</font><hr><h3 id="不能说的秘密"><a href="#不能说的秘密" class="headerlink" title="不能说的秘密"></a>不能说的秘密</h3><p>‍“有秘密的人都觉得孤单，这很正常。”</p><font color='#6e6e6e' size=2> 2022-02-15 09:11:41</font><hr><p>‍道理是道理，生活是生活。</p><font color='#6e6e6e' size=2> 2022-02-15 09:12:33</font><hr><p>‍即使再自认老成，自己身上也还是挂着年轻人才享有的勇气和尖锐。不懂放手，不愿后退，不肯甘心。</p><font color='#6e6e6e' size=2> 2022-02-15 09:12:39</font><hr><p>‍开口是需要勇气的，一种承担责任的勇气。　　因为不说是遗憾，说了就只剩后悔了。</p><font color='#6e6e6e' size=2> 2022-02-15 09:13:26</font><hr><h3 id="仇恨着的人都孤单"><a href="#仇恨着的人都孤单" class="headerlink" title="仇恨着的人都孤单"></a>仇恨着的人都孤单</h3><p>‍上班没有上学有意思，人都没目标了。”</p><font color='#6e6e6e' size=2> 2022-02-15 18:27:43</font><hr><h3 id="如果没有黄蓉"><a href="#如果没有黄蓉" class="headerlink" title="如果没有黄蓉"></a>如果没有黄蓉</h3><p>‍所有我想要恨的人不是死了就是远离了我的生活，所以其他人都站在活人的角度可怜他们，念着他们的好，只有我还在恨着，只有我跟死人过不去，觉得有点儿孤单。</p><font color='#6e6e6e' size=2> 2022-02-15 18:30:11</font><hr><h3 id="线索人物"><a href="#线索人物" class="headerlink" title="线索人物"></a>线索人物</h3><p>‍叔本华说过，一个真正漂亮的女人不会拥有一个真正的同性朋友——当然，我也不知道是不是叔本华说的。</p><font color='#6e6e6e' size=2> 2022-02-15 18:35:27</font><hr><h3 id="小白女主与美丽反派"><a href="#小白女主与美丽反派" class="headerlink" title="小白女主与美丽反派"></a>小白女主与美丽反派</h3><p>‍《东邪西毒》里有句话说，任何人都可以变得狠毒，只要他知道什么是忌妒。</p><font color='#6e6e6e' size=2> 2022-02-15 18:37:58</font><hr><h3 id="看客"><a href="#看客" class="headerlink" title="看客"></a>看客</h3><p>‍“所有能称得上是安慰的话，大部分是废话。”</p><font color='#6e6e6e' size=2> 2022-02-15 18:41:51</font><hr><h3 id="其实是赌气"><a href="#其实是赌气" class="headerlink" title="其实是赌气"></a>其实是赌气</h3><p>‍你活着时爱谁无所谓，总之你死的时候，只能跟我埋在一起。</p><font color='#6e6e6e' size=2> 2022-02-15 18:43:14</font><hr><p>‍听不到自然有听不到的理由，她相信上天为她好。</p><font color='#6e6e6e' size=2> 2022-02-15 18:43:57</font><hr><p>‍的确什么事都没有发生过——如果她的心事不算事的话。</p><font color='#6e6e6e' size=2> 2022-02-15 18:44:03</font><hr><p>‍所谓矫情，就是明明在赌气，偏偏做出一副看破世事的样子，动不动就说自己已经心冷。</p><font color='#6e6e6e' size=2> 2022-02-15 18:45:01</font><hr><h3 id="洛枳，加油"><a href="#洛枳，加油" class="headerlink" title="洛枳，加油"></a>洛枳，加油</h3><p>‍这就是爱情吧。如果爱情不能把一个人拉扯到走样变形，那么它的魔力就未免太小了。</p><font color='#6e6e6e' size=2> 2022-02-15 18:46:18</font><hr><h3 id="所谓浪漫，就是没有后来"><a href="#所谓浪漫，就是没有后来" class="headerlink" title="所谓浪漫，就是没有后来"></a>所谓浪漫，就是没有后来</h3><p>‍这个世界太大了。无论你觉得自己多优秀、多独特、多有个性，或者多变态、多阴暗、多没良心——你永远不会孤独。因为世界上没有独一无二这回事。</p><font color='#6e6e6e' size=2> 2022-02-15 18:50:11</font><hr><h3 id="后来"><a href="#后来" class="headerlink" title="后来"></a>后来</h3><p>‍浪漫永远都是旁观者看出来的。</p><font color='#6e6e6e' size=2> 2022-02-15 18:52:14</font><hr><p>‍她是骄傲的，从家庭到学业到爱情，她挣扎着，每走任何一步，都是因为她骄傲地仰着头看着前方。　　也许只是因为他恰好总在她前方而已。</p><font color='#6e6e6e' size=2> 2022-02-15 18:55:05</font><hr><h3 id="友情出演"><a href="#友情出演" class="headerlink" title="友情出演"></a>友情出演</h3><p>‍在不了解的状况下喜欢上一个人，发现那个人真实的一面比你想象的还要美好，这应该算得上幸运。</p><font color='#6e6e6e' size=2> 2022-02-15 21:09:33</font><hr><p>‍世界上的确没有‘如果’，”洛枳手指敲着桌子，“不过有很多‘但是’。</p><font color='#6e6e6e' size=2> 2022-02-15 21:12:25</font><hr><p>‍爱情只是一种感觉而已，她们却都拼命搜集证据。</p><font color='#6e6e6e' size=2> 2022-02-15 21:12:53</font><hr><p>‍任何人都是这样，处理别人的事情总是大刀阔斧，一下抓住主要问题，轮到自己却纠缠于细枝末节不肯放手。</p><font color='#6e6e6e' size=2> 2022-02-15 21:14:43</font><hr><p>‍很少有男生愿意费尽心思地去用女生的方式来救赎一个女生，而且，不是为了得到。</p><font color='#6e6e6e' size=2> 2022-02-15 21:14:50</font><hr><p>‍无论真假。　　说者无意，听者戳心窝。</p><font color='#6e6e6e' size=2> 2022-02-15 21:15:01</font><hr><h3 id="我们约会吧"><a href="#我们约会吧" class="headerlink" title="我们约会吧"></a>我们约会吧</h3><p>‍既然已经这样，就当作做梦好了，好歹也是一场青春，她还没有像别人那样好好装扮着和喜欢的人并肩前行的经历。</p><font color='#6e6e6e' size=2> 2022-02-15 21:15:34</font><hr><h3 id="心有灵犀"><a href="#心有灵犀" class="headerlink" title="心有灵犀"></a>心有灵犀</h3><p>‍那心情，取决于经过了多少时间，更取决于，他们两个人最终的结果。</p><font color='#6e6e6e' size=2> 2022-02-16 08:28:45</font><hr><p>‍“好像缘分是自己跑过来，而不是你故意寻觅来的。”</p><font color='#6e6e6e' size=2> 2022-02-16 08:33:01</font><hr><p>‍真好。他们的爱情那样坦荡。爱情本来就应该这么坦荡。</p><font color='#6e6e6e' size=2> 2022-02-16 08:33:16</font><hr><p>‍看书在更多的时候没有什么指导意义，反而让我知道，世界上不缺少活得憋屈的人。”</p><font color='#6e6e6e' size=2> 2022-02-16 08:33:36</font><hr><p>‍“爱，可燃烧，或存在，但不会两者并存。”</p><font color='#6e6e6e' size=2> 2022-02-16 08:33:45</font><hr><h3 id="雨天"><a href="#雨天" class="headerlink" title="雨天"></a>雨天</h3><p>‍道歉是第二重伤害，与其重新提及，还不如当作什么都没有发生。</p><font color='#6e6e6e' size=2> 2022-02-16 08:43:50</font><hr><p>‍原来在乎一个人的时候，表面上装成什么样子都没有用，那些曾经被她鄙视的种种情绪一一放肆地浮上心头。</p><font color='#6e6e6e' size=2> 2022-02-16 08:44:57</font><hr><h3 id="旁观者的青春"><a href="#旁观者的青春" class="headerlink" title="旁观者的青春"></a>旁观者的青春</h3><p>‍大街上偶尔有几个行人匆匆穿过夜色，最热闹的却是飞扬的垃圾</p><font color='#6e6e6e' size=2> 2022-02-16 08:48:57</font><hr><h3 id="施华洛世奇"><a href="#施华洛世奇" class="headerlink" title="施华洛世奇"></a>施华洛世奇</h3><p>‍旁观者不负责任的打抱不平，永远只具有添乱的功效。</p><font color='#6e6e6e' size=2> 2022-02-16 08:52:36</font><hr><p>‍所以这个世界上的故事层出不穷，一个比一个精彩，永远不冷场。</p><font color='#6e6e6e' size=2> 2022-02-16 08:54:39</font><hr><h3 id="告白"><a href="#告白" class="headerlink" title="告白"></a>告白</h3><p>‍伟大领袖毛主席曾经说过，所有不以结婚为目的的恋爱都是耍流氓。</p><font color='#6e6e6e' size=2> 2022-02-16 08:57:40</font><hr><h3 id="对不起"><a href="#对不起" class="headerlink" title="对不起"></a>对不起</h3><p>‍对不起。　　我用了你珍藏的记忆去伪装、表演、现宝、取悦于人。</p><font color='#6e6e6e' size=2> 2022-02-16 09:00:03</font><hr><h3 id="被偏爱的都有恃无恐"><a href="#被偏爱的都有恃无恐" class="headerlink" title="被偏爱的都有恃无恐"></a>被偏爱的都有恃无恐</h3><p>‍“也许是某种自我保护吧。事实已经够糟的了，何必在回忆的时候还要为难自己。”</p><font color='#6e6e6e' size=2> 2022-02-16 09:06:23</font><hr><p>‍被伤得再狠，只要对方问一句“疼不疼”，就能活过来。</p><font color='#6e6e6e' size=2> 2022-02-16 09:07:51</font><hr><h3 id="破碎的湄公河"><a href="#破碎的湄公河" class="headerlink" title="破碎的湄公河"></a>破碎的湄公河</h3><p>‍承担他人的痛苦的时候，我们都分外坚强。</p><font color='#6e6e6e' size=2> 2022-02-16 18:43:14</font><hr><h3 id="凭什么不恨"><a href="#凭什么不恨" class="headerlink" title="凭什么不恨"></a>凭什么不恨</h3><p>‍世态炎凉。一腔怨恨平摊到世间众人的头上，每个人得到的责问都轻得不如一声叹息。</p><font color='#6e6e6e' size=2> 2022-02-16 18:43:46</font><hr><p>‍以前的人多好，不管爱不爱，感情积累起来，照样白头不相离。　　红绸子一牵，生死都羁绊。就算无论如何都生不出爱情，至少在心里烙下印记，永远抹不掉。何况，情有独钟多半是小说里作者的幻想，人心难测，这么多年，世间不是也只出了一对梁祝化蝶？</p><font color='#6e6e6e' size=2> 2022-02-16 18:44:22</font><hr><p>‍死人哪里有活人可怕</p><font color='#6e6e6e' size=2> 2022-02-16 18:45:35</font><hr><h3 id="讲故事的人才是上帝"><a href="#讲故事的人才是上帝" class="headerlink" title="讲故事的人才是上帝"></a>讲故事的人才是上帝</h3><p>‍她的故事，无非就是暗恋，世界上最容易保全也最容易毁掉的感情。</p><font color='#6e6e6e' size=2> 2022-02-17 08:42:01</font><hr><h3 id="情深说话未曾讲"><a href="#情深说话未曾讲" class="headerlink" title="情深说话未曾讲"></a>情深说话未曾讲</h3><p>‍她曾经以为他是遮挡着她成长道路的障碍和心魔，却从来不知道，他也是她十几年的人生中千里迢迢绵延不断的一方阳光。</p><font color='#6e6e6e' size=2> 2022-02-21 08:56:03</font><hr><h3 id="致我们终将腐朽的青春"><a href="#致我们终将腐朽的青春" class="headerlink" title="致我们终将腐朽的青春"></a>致我们终将腐朽的青春</h3><p>‍好像生怕走近一点点，全世界都会识破她的意图，戳穿她的心思。</p><font color='#6e6e6e' size=2> 2022-02-21 18:34:49</font><hr><p>‍回忆的时空中有许多小小的念想，像漂浮的气泡，被真相的细针一个个戳破。</p><font color='#6e6e6e' size=2> 2022-02-21 18:42:54</font><hr><p>‍人的执念并不是想斩断就斩得断的，你可以尽情地发誓要忘记，但是过后只能徒劳地斥责自己的无能和出尔反尔。</p><font color='#6e6e6e' size=2> 2022-02-21 18:42:54</font><hr><p>‍被大家这样善意嘲笑和幸灾乐祸，其实真的是因为你的强大让我们心服口服。</p><font color='#6e6e6e' size=2> 2022-02-21 18:54:18</font><hr><p>‍她从他身上收获了很多色彩，他却从来没有因为她的索取失去什么，反而得到了很多理解和祝福。</p><font color='#6e6e6e' size=2> 2022-02-21 18:54:20</font><hr><p>‍她总是觉得，那本日记就是回去的钥匙。而现在她回不去了。</p><font color='#6e6e6e' size=2> 2022-02-21 18:54:46</font><hr><h3 id="我们都是说谎精"><a href="#我们都是说谎精" class="headerlink" title="我们都是说谎精"></a>我们都是说谎精</h3><p>‍“说两句真心话会死吗？你家人都是这个毛病吗？是遗传吗？”</p><font color='#6e6e6e' size=2> 2022-02-21 18:57:54</font><hr><p>‍这才是爱吧。她真的太肤浅了，沉浸在自己的伤怀中，以为沉默着负担了一切，其实从来都不够坦荡宽厚，总是计较着得失利弊。　　她的爱和恨，其实最后都反射给了自己，所以才会伤得那么深。</p><font color='#6e6e6e' size=2> 2022-02-21 18:58:14</font><hr><h3 id="只要得不到"><a href="#只要得不到" class="headerlink" title="只要得不到"></a>只要得不到</h3><p>‍也许有一天你不再喜欢他，但不可以厌弃曾经喜欢他的你自己。毕竟他是你的全部青春，他如果很不堪，那你的青春就等于喂狗了。”</p><font color='#6e6e6e' size=2> 2022-02-22 08:33:21</font><hr><p>‍说出来，咽下去，万众瞩目的追求，或者不为人知的爱恋，并没有哪种更加高明，也没有哪种更为高贵。　　只要得不到，就一样百爪挠心，痛得不差分毫。</p><font color='#6e6e6e' size=2> 2022-02-22 08:33:54</font><hr><h3 id="平衡木"><a href="#平衡木" class="headerlink" title="平衡木"></a>平衡木</h3><p>‍暗恋成了一种习惯，卑微已经根植到了骨子里，刮骨疗毒都抹不干净。</p><font color='#6e6e6e' size=2> 2022-02-22 08:43:02</font><hr><p>‍这个世界，向上爬永远不是一件容易的事，除非有人托着你往上跳。</p><font color='#6e6e6e' size=2> 2022-02-22 08:44:36</font><hr><p>‍“如果我想娶你的话，那这就不算耍流氓了，对不对？”</p><font color='#6e6e6e' size=2> 2022-02-22 08:45:36</font><hr><h3 id="真相有什么所谓"><a href="#真相有什么所谓" class="headerlink" title="真相有什么所谓"></a>真相有什么所谓</h3><p>‍虽然我不能说了解你，但至少清楚，你绝不会低姿态地去解释或者辩白。</p><font color='#6e6e6e' size=2> 2022-02-22 08:46:21</font><hr><p>‍承诺唯一的用途就是有朝一日用来对着自己抽耳光。</p><font color='#6e6e6e' size=2> 2022-02-22 08:47:11</font><hr><h3 id="劳动人民的智慧"><a href="#劳动人民的智慧" class="headerlink" title="劳动人民的智慧"></a>劳动人民的智慧</h3><p>‍爱情其实永远是男人和男人的战争。要忘记一个旧男人，最迅速的方式就是认识一个新男人。</p><font color='#6e6e6e' size=2> 2022-02-22 08:55:45</font><hr><p>‍说出口的故事就像冰山山顶，那些真相都潜伏在海面之下，隐秘而庞大。</p><font color='#6e6e6e' size=2> 2022-02-22 08:57:08</font><hr><h3 id="难得糊涂"><a href="#难得糊涂" class="headerlink" title="难得糊涂"></a>难得糊涂</h3><p>‍，男人要长大呢，一定要没事找事给自己添一个负担，美其名曰学会承担责任。</p><font color='#6e6e6e' size=2> 2022-02-22 09:01:53</font><hr><p>‍洛枳今天才知道，他们不是没有棱角，只是那些棱角被稀泥包裹起来了而已。</p><font color='#6e6e6e' size=2> 2022-02-22 09:04:15</font><hr><h3 id="最是微笑虐人心"><a href="#最是微笑虐人心" class="headerlink" title="最是微笑虐人心"></a>最是微笑虐人心</h3><p>‍世间大多数阴差阳错，其实一开始是可以说清楚的，不是不可回避，也不是造化弄人。阻挡在其中的，都是彼此的自尊和所谓的体谅。</p><font color='#6e6e6e' size=2> 2022-02-22 09:10:24</font><hr><p>‍“如果错过了太阳时你流了泪，那么你也要错过群星了。”泰戈尔总是说些看似温暖实则残酷的话。</p><font color='#6e6e6e' size=2> 2022-02-22 09:11:44</font><hr><h3 id="再见，皇帝陛下"><a href="#再见，皇帝陛下" class="headerlink" title="再见，皇帝陛下"></a>再见，皇帝陛下</h3><p>‍她最好的年华全部都铺展在他的细枝末节中，可是道别的时候，她都没有抬起头好好看过他一眼。</p><font color='#6e6e6e' size=2> 2022-02-22 09:13:08</font><hr><p>‍误会其实是最最微不足道的障碍。他们之间没有误会，因为他们从来没有彼此理解过。</p><font color='#6e6e6e' size=2> 2022-02-22 09:13:14</font><hr><h3 id="没有人活该被俯视"><a href="#没有人活该被俯视" class="headerlink" title="没有人活该被俯视"></a>没有人活该被俯视</h3><p>‍这个世界上有些人生来万众瞩目，有些人生来不甘寂寞。如果天性不甘寂寞的那个人恰巧拥有万众瞩目的命运，那自然是两全其美。”</p><font color='#6e6e6e' size=2> 2022-02-22 18:36:30</font><hr><p>‍人需要各种各样的形式来证明自己，那些过后冷静下来会觉得愚不可及的各种折腾，在当时的情绪中却是重要的过程。就好像没有喷火龙的阻隔，骑士和公主的爱情就不会圆满。</p><font color='#6e6e6e' size=2> 2022-02-22 18:36:59</font><hr><h3 id="你才喜欢郑文瑞"><a href="#你才喜欢郑文瑞" class="headerlink" title="你才喜欢郑文瑞"></a>你才喜欢郑文瑞</h3><p>‍无人背后不说人。有些人的存在好像仅仅是用来被娱乐的，单纯地协助促进了同学关系的融洽进展。</p><font color='#6e6e6e' size=2> 2022-02-22 18:38:22</font><hr><p>‍“你果然不会懂得。因为你没有遗憾，所以你从来不回头</p><font color='#6e6e6e' size=2> 2022-02-22 18:38:55</font><hr><p>‍旁观者永远保留着武断的自信。</p><font color='#6e6e6e' size=2> 2022-02-22 18:38:58</font><hr><h3 id="我为什么爱你"><a href="#我为什么爱你" class="headerlink" title="我为什么爱你"></a>我为什么爱你</h3><p>‍做朋友是起点不是终点。只做朋友怎么可能满足。</p><font color='#6e6e6e' size=2> 2022-02-22 18:42:31</font><hr><h3 id="她与地坛"><a href="#她与地坛" class="headerlink" title="她与地坛"></a>她与地坛</h3><p>‍旁观的时候，每个人都是智者。</p><font color='#6e6e6e' size=2> 2022-02-23 08:23:06</font><hr><h3 id="明天又是崭新的一天"><a href="#明天又是崭新的一天" class="headerlink" title="明天又是崭新的一天"></a>明天又是崭新的一天</h3><p>‍她没有赶上好时候。无论什么事，她永远都慢一拍，永远错过最好的时光。</p><font color='#6e6e6e' size=2> 2022-02-23 08:25:32</font><hr><p>‍能在阳光下晒干不怕人知的伤心事，再苦也干净透亮。要知道，这世上有多少人的难过是不可说的？</p><font color='#6e6e6e' size=2> 2022-02-23 08:26:47</font><hr><p>‍如果我能对爱我的人好一点儿，离讨厌我的人远一点儿，永远不去试图讨好和解释，我是不是会得到更多呢？”</p><font color='#6e6e6e' size=2> 2022-02-23 08:27:11</font><hr><h3 id="人间烟火"><a href="#人间烟火" class="headerlink" title="人间烟火"></a>人间烟火</h3><p>‍多么充实的生活，好像轻易就和遇见盛淮南之前的日子毫无痕迹地拼接起来了，中间半年的辗转反侧牵扯纠结，从来没有发生过。</p><font color='#6e6e6e' size=2> 2022-02-23 08:30:02</font><hr><p>‍很多事情，可以想通，可以看破，然而却不能放下，不能忘记。</p><font color='#6e6e6e' size=2> 2022-02-23 08:29:55</font><hr><p>‍那么就算不能放下，不能忘记，她也可以不再提及，不再想起。</p><font color='#6e6e6e' size=2> 2022-02-23 08:30:03</font><hr><p>‍只要还活在热闹的人间，哪怕坐在鼎沸的人声中感受到的只是浮夸的虚热，久而久之，终究会把记忆蒸发得一干二净。</p><font color='#6e6e6e' size=2> 2022-02-23 08:30:06</font><hr><h3 id="乱"><a href="#乱" class="headerlink" title="乱"></a>乱</h3><p>‍在感情问题上，凡人自作聪明的举动不但无法力挽狂澜，反而极有可能推波助澜。</p><font color='#6e6e6e' size=2> 2022-02-23 08:34:50</font><hr><p>‍情感和理性交战，胜利的永远都是情感。</p><font color='#6e6e6e' size=2> 2022-02-23 08:37:29</font><hr><h3 id="夜奔"><a href="#夜奔" class="headerlink" title="夜奔"></a>夜奔</h3><p>‍男人的孩子气是让女人安心的理由。</p><font color='#6e6e6e' size=2> 2022-02-23 08:41:39</font><hr><h3 id="我听说的你"><a href="#我听说的你" class="headerlink" title="我听说的你"></a>我听说的你</h3><p>‍对暗恋的人来说，彻底封口不言固然是一种自我保护，然而将一颗真心藏在戏谑夸张的示爱中供人玩笑，其实更是一种安全的宣泄</p><font color='#6e6e6e' size=2> 2022-02-23 08:47:02</font><hr><h3 id="每朵云都下落不明"><a href="#每朵云都下落不明" class="headerlink" title="每朵云都下落不明"></a>每朵云都下落不明</h3><p>‍理智上绝对是非分明。”　　感情上却不知好歹。</p><font color='#6e6e6e' size=2> 2022-02-23 08:49:01</font><hr><h3 id="相见恨晚"><a href="#相见恨晚" class="headerlink" title="相见恨晚"></a>相见恨晚</h3><p>‍所有一言难尽的故事，他们都学会了不再刨根问底，也没有时间和心情再去聆听细节。</p><font color='#6e6e6e' size=2> 2022-02-23 08:52:31</font><hr><p>‍生活总是深深浅浅、光影交错。有人得到浓墨重彩，有人轻描淡写地经过，有人在你生命里屡屡划过却留不下痕迹。而有些人，一面之缘就嵌入大脑回路深处，走进记忆里，仿佛不请自来，过期居留。</p><font color='#6e6e6e' size=2> 2022-02-23 08:54:20</font><hr><p>‍世界上很多事情，都开始于那一眼若有所思的打量。</p><font color='#6e6e6e' size=2> 2022-02-23 08:54:34</font><hr><h3 id="Two-strangers-fell-in-love（两个陌生人坠入爱河）"><a href="#Two-strangers-fell-in-love（两个陌生人坠入爱河）" class="headerlink" title="Two strangers fell in love（两个陌生人坠入爱河）"></a>Two strangers fell in love（两个陌生人坠入爱河）</h3><p>‍我觉得，分手后，只有不甘心的那个人，言谈中才会总带着讥讽。</p><font color='#6e6e6e' size=2> 2022-02-23 08:55:39</font><hr><p>‍不是不会再遇见爱情。只是长大了，见识得多了，再也不会用那样的方式遇见爱情了。</p><font color='#6e6e6e' size=2> 2022-02-23 08:56:10</font><hr><p>‍两个陌生人坠入爱河，只有一个知道爱绝非巧合。</p><font color='#6e6e6e' size=2> 2022-02-23 08:57:46</font><hr><h3 id="红玫瑰与白玫瑰"><a href="#红玫瑰与白玫瑰" class="headerlink" title="红玫瑰与白玫瑰"></a>红玫瑰与白玫瑰</h3><p>‍规矩是一种最容易被破坏的东西，不遵守规矩会带来额外的利益，利益不均又会导致因为不公平而产生的愤懑，对于公平的追求恰恰又会打破平衡，最终被踩得一地渣滓的，就是形同虚设的规矩。</p><font color='#6e6e6e' size=2> 2022-02-23 08:58:47</font><hr><p>‍曾经她喜欢他，却不会被这种突如其来的念头击中。</p><font color='#6e6e6e' size=2> 2022-02-23 09:01:29</font><hr><h3 id="时间的罐子"><a href="#时间的罐子" class="headerlink" title="时间的罐子"></a>时间的罐子</h3><p>‍曾经有位作家说过，他会不断地把自己最美好的时光转移到文字中去，借以逃避时间的流逝。</p><font color='#6e6e6e' size=2> 2022-02-23 09:06:11</font><hr><p>‍时间偷走的选择，总会在未来用它喜爱的方式还给你。</p><font color='#6e6e6e' size=2> 2022-02-23 09:07:35</font><hr><p>‍“不管以后发生什么，你一定要记得，我是真心喜欢你的。”</p><font color='#6e6e6e' size=2> 2022-02-23 09:08:08</font><hr><p>‍爱让人是非不分，这可能是它最可贵的地方。</p><font color='#6e6e6e' size=2> 2022-02-23 09:08:14</font><hr><h3 id="往事并不如烟"><a href="#往事并不如烟" class="headerlink" title="往事并不如烟"></a>往事并不如烟</h3><p>‍儿童的愈合能力没有想象中强大，那道阴影至今也没有淡退，无论是身体上的还是心灵上的。</p><font color='#6e6e6e' size=2> 2022-02-23 19:02:50</font><hr><p>‍爱情不怕身体残破，却承受不了灵魂的面目全非。</p><font color='#6e6e6e' size=2> 2022-02-23 19:02:50</font><hr><p>‍最深沉的阴影，背面总有最灿烂的光。</p><font color='#6e6e6e' size=2> 2022-02-23 19:04:42</font><hr><p>‍所谓淡定，所谓高姿态，所谓心平气和，不过就是因为你早就是赢家。</p><font color='#6e6e6e' size=2> 2022-02-23 19:05:07</font><hr><h3 id="你给我多少时间"><a href="#你给我多少时间" class="headerlink" title="你给我多少时间"></a>你给我多少时间</h3><p>‍一年前她听说他们分手，也曾听说过不少人的闲言碎语，最后拼凑出的原因却很普通。　　和所有异地恋的分手都一样，低估了时间与距离，高估了自我和爱情。</p><font color='#6e6e6e' size=2> 2022-02-23 19:05:18</font><hr><p>‍真正的幸福往往都是惶恐的。某一个瞬间，洛枳突然伤感起来</p><font color='#6e6e6e' size=2> 2022-02-23 19:06:33</font><hr><p>‍命运的地图早已写就，纵横交错安排妥当，因果前缘一个不落，好像早就拿着剪刀，站在恰好的时间节点，咔嚓一下，剪掉所有的美梦。</p><font color='#6e6e6e' size=2> 2022-02-23 19:06:36</font><hr><p>‍“我记得，蒙肯说过：‘男人通过吹嘘来表达爱，女人则通过倾听来表达爱。而一旦女人的智力长进到某一程度，她就几乎难以找到一个丈夫，因为她倾听的时候，内心必然有嘲讽的声音响动。’”</p><font color='#6e6e6e' size=2> 2022-02-23 19:07:00</font><hr><p>‍我还是希望全世界都喜欢你，因为你也喜欢全世界都喜欢你</p><font color='#6e6e6e' size=2> 2022-02-23 19:07:13</font><hr><h3 id="序曲"><a href="#序曲" class="headerlink" title="序曲"></a>序曲</h3><p>‍你要是爱我，就应该立刻笑着说，我不忙。</p><font color='#6e6e6e' size=2> 2022-02-23 19:13:58</font><hr><p>‍容易动情的人，其实心最狠。</p><font color='#6e6e6e' size=2> 2022-02-23 19:14:14</font><hr><p>‍不试探，不追究，就不会尴尬，不需要直面现实。</p><font color='#6e6e6e' size=2> 2022-02-23 19:14:24</font><hr><h3 id="灰姑娘"><a href="#灰姑娘" class="headerlink" title="灰姑娘"></a>灰姑娘</h3><p>‍年少时仰望的从一而终、一尘不染的神圣爱情，最终不过就是一念起一念灭，和其他事一样，没什么特别。</p><font color='#6e6e6e' size=2> 2022-02-23 19:17:20</font><hr><p>‍大人本身就是如此复杂的动物，阴暗的内心，牵绊的关系，披着伪装的自尊心，怎么可能酿造出一份不含杂质的感情？</p><font color='#6e6e6e' size=2> 2022-02-23 19:17:23</font><hr><h3 id="我愿意"><a href="#我愿意" class="headerlink" title="我愿意"></a>我愿意</h3><p>‍忠诚有什么意义呢？人真正应该做的，是对自己的感觉和情绪忠诚。你怎样想，怎样感觉，就怎样选择。成功失败，得到失去，都是选择之后的结果，却不应该是选择时的原因。”</p><font color='#6e6e6e' size=2> 2022-02-23 19:20:50</font><hr><p>‍人心难测，世事无常。但我不愿意将自己的一切都交予这些不确定。总有一些事情，是我不计后果，跟随本心，甘愿乐意。</p><font color='#6e6e6e' size=2> 2022-02-23 19:20:58</font><hr><h3 id="所有人都会说再见"><a href="#所有人都会说再见" class="headerlink" title="所有人都会说再见"></a>所有人都会说再见</h3><p>‍没有什么不可言说的难过和计较，那样的确更好。</p><font color='#6e6e6e' size=2> 2022-02-23 19:22:24</font><hr><h3 id="天早灰蓝偏未晚"><a href="#天早灰蓝偏未晚" class="headerlink" title="天早灰蓝偏未晚"></a>天早灰蓝偏未晚</h3><p>‍相比你众叛亲离与我相依为命，我更希望你得天独厚，应有尽有，被全世界喜爱，哪怕彼此相忘于江湖。</p><font color='#6e6e6e' size=2> 2022-02-23 19:35:31</font><hr><h3 id="橘生淮南"><a href="#橘生淮南" class="headerlink" title="橘生淮南"></a>橘生淮南</h3><p>‍她的爱情开始时是个秘密，当秘密揭开，爱情也结束了。</p><font color='#6e6e6e' size=2> 2022-02-23 19:46:43</font><hr><p>‍“她当时对我说，我们只考虑着分开对彼此好，从来没有想过，如果在一起，对两个人有多好。”</p><font color='#6e6e6e' size=2> 2022-02-23 19:47:05</font><hr><p>‍从这份感情在暗无天日的内心深处滋生的那一刻起，她期待的就只是能和他在一起。他是盛淮南，倾注了她多年感情的盛淮南。退学也是盛淮南，变成穷小子了仍是盛淮南。　　你再弱小也是你，别人再强大也是别人。</p><font color='#6e6e6e' size=2> 2022-02-23 19:47:48</font><hr><h3 id="后记：时间的女儿"><a href="#后记：时间的女儿" class="headerlink" title="后记：时间的女儿"></a>后记：时间的女儿</h3><p>‍一对很有爱的情侣，一个聪明的、懂得如何去维持关系的女生，和一个还算珍惜的男生。</p><font color='#6e6e6e' size=2> 2022-02-23 19:48:31</font><hr><p>‍有些亲密不属于你，有些人是错误的。即使你拥有了，也终究会将一切搞砸。</p><font color='#6e6e6e' size=2> 2022-02-23 19:48:35</font><hr><p>‍你们的梦想应该是一个对的人，一段健康稳固、亲密美好的关系，以及共同变得更好的努力方向，而远远不该是暗恋开花结果，虽然这很美好。</p><font color='#6e6e6e' size=2> 2022-02-23 19:48:42</font><hr><h3 id="番外之二：当时的月亮"><a href="#番外之二：当时的月亮" class="headerlink" title="番外之二：当时的月亮"></a>番外之二：当时的月亮</h3><p>‍生活永远没有清晰的边界，所有底线上都铺满了渐变色。</p><font color='#6e6e6e' size=2> 2022-02-23 20:05:06</font>]]></content>
    
    
    <categories>
      
      <category>读书笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>读书笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 升级版本（windows）</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%EF%BC%88windows%EF%BC%89.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%EF%BC%88windows%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、从官网下载最新安装包"><a href="#一、从官网下载最新安装包" class="headerlink" title="一、从官网下载最新安装包"></a>一、从官网下载最新安装包</h2><p>在 git 官网下载安装包并安装。Git For Windows 最新下载地址。下载下来后，双击开始，然后一直点下一步，完事。</p><h2 id="二、【推荐】通过升级命令一键更新"><a href="#二、【推荐】通过升级命令一键更新" class="headerlink" title="二、【推荐】通过升级命令一键更新"></a>二、【推荐】通过升级命令一键更新</h2><p>按 windows 键+S 键，在弹出的界面输入 Git Bash，然后输入下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git update-git-for-windows<br></code></pre></td></tr></table></figure><p>它就会开始自动下载了：</p><p>​<img src="https://image.loufengkai.top/siyuan/202301152207180.png" alt="">​</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由于 i++ 与++i 的运算顺序不同而导致的死循环</title>
    <link href="/%E7%BC%96%E7%A8%8B/Csharp/%E7%94%B1%E4%BA%8Ei++%E4%B8%8E++i%E7%9A%84%E8%BF%90%E7%AE%97%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.html"/>
    <url>/%E7%BC%96%E7%A8%8B/Csharp/%E7%94%B1%E4%BA%8Ei++%E4%B8%8E++i%E7%9A%84%E8%BF%90%E7%AE%97%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.html</url>
    
    <content type="html"><![CDATA[<p>死循环的原因：i++ 和 ++i 的基本功能是相同的，都是对变量 i 进行自增 1 运算，从功能上讲相当于 i =i+1 ;<br>两个的区别在于：int i=1,a=0;<br>i++ 先运算在赋值，例如 a=i++, 先运算 a=i, 后运算 i=i+1, 所以结果是 a == 1；<br>++i 先赋值在运算，例如 a=++i, 先运算 i=i+1, 后运算 a=i, 所以结果是 a == 2。</p><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultEntity <span class="hljs-title">SyncDataXml</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> interfaceCode, SyncDataParam param</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> curPage = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> nextPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> totalPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(param.Page != <span class="hljs-number">0</span>)<br>     &#123;<br>         curPage = param.Page;<br>         nextPage = curPage++;<span class="hljs-comment">// 死循环的原因</span><br>     &#125;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">if</span>(nextPage &lt;= totalPage)<br>     &#123;<br>         <span class="hljs-keyword">var</span> nextParam = <span class="hljs-keyword">new</span> SyncDataParam<br>         &#123;<br>             LastUpdateTime = param.LastUpdateTime,<br>             Page = nextPage<br>             &#125;;<br>         result = SyncDataXml(interfaceCode, nextParam);<br>     &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultEntity <span class="hljs-title">SyncDataXml</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> interfaceCode, SyncDataParam param</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> curPage = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> nextPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> totalPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(param.Page != <span class="hljs-number">0</span>)<br>     &#123;<br>         curPage = param.Page;<br>         nextPage = ++curPage;<span class="hljs-comment">// 解决</span><br>     &#125;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">if</span>(nextPage &lt;= totalPage)<br>     &#123;<br>         <span class="hljs-keyword">var</span> nextParam = <span class="hljs-keyword">new</span> SyncDataParam<br>         &#123;<br>             LastUpdateTime = param.LastUpdateTime,<br>             Page = nextPage<br>             &#125;;<br>         result = SyncDataXml(interfaceCode, nextParam);<br>     &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 SQL 存储过程完整流程</title>
    <link href="/%E7%BC%96%E7%A8%8B/SQL/%E4%BD%BF%E7%94%A8SQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.html"/>
    <url>/%E7%BC%96%E7%A8%8B/SQL/%E4%BD%BF%E7%94%A8SQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<ul><li>新建存储过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE [数据库名]<br>GO<br><span class="hljs-keyword">create</span> proc myinsert <span class="hljs-comment">-- 创建一个存储过程，名称为 myinsert</span><br>    <span class="hljs-variable">@username</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<span class="hljs-comment">--注意这里的逗号，多个参数用逗号隔开</span><br>    <span class="hljs-variable">@password</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-variable">@name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-variable">@usertype</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-variable">@createpeople</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">--这里写参数，如果有的话；没有的话就空着</span><br>    <span class="hljs-keyword">as</span><br>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SystemUsers(UserName,PassWord,Name,UserType,CreatPeople)<br>    <span class="hljs-keyword">values</span>(<span class="hljs-variable">@username</span>,<span class="hljs-variable">@password</span>,<span class="hljs-variable">@name</span>,<span class="hljs-variable">@usertype</span>,<span class="hljs-variable">@createpeople</span>)<br>    <span class="hljs-comment">--这里写具体语句，可以写 N 个</span><br>    go<span class="hljs-comment">--可加可不加，go 的意思是另起一页，相当于下一个功能块。如果下边不写语句，可以不加！</span><br></code></pre></td></tr></table></figure><ul><li>C# 调用存储过程</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> strsql = <span class="hljs-string">&quot;Data Source=localhost;Initial Catalog=######;Integrated Security=True&quot;</span>;<span class="hljs-comment">//数据库链接字符串</span><br><span class="hljs-built_in">string</span> sql = <span class="hljs-string">&quot;SelectUserName&quot;</span>;<span class="hljs-comment">//要调用的存储过程名</span><br>SqlConnection conStr = <span class="hljs-keyword">new</span> SqlConnection(strsql);<span class="hljs-comment">//SQL 数据库连接对象，以数据库链接字符串为参数</span><br>SqlCommand comStr = <span class="hljs-keyword">new</span> SqlCommand(sql, conStr);<span class="hljs-comment">//SQL 语句执行对象，第一个参数是要执行的语句，第二个是数据库连接对象</span><br>comStr.CommandType = CommandType.StoredProcedure;<span class="hljs-comment">//因为要使用的是存储过程，所以设置执行类型为存储过程</span><br><span class="hljs-comment">//依次设定存储过程的参数</span><br>comStr.Parameters.Add(<span class="hljs-string">&quot;@Param1&quot;</span>, SqlDbType.Text).Value = <span class="hljs-string">&quot;####&quot;</span>;<br>conStr.Open();<span class="hljs-comment">//打开数据库连接</span><br><span class="hljs-comment">//执行存储过程</span><br>SqlDataAdapter SqlDataAdapter1 = <span class="hljs-keyword">new</span> SqlDataAdapter(comStr);<br>DataTable DT=<span class="hljs-keyword">new</span> DataTable ();<br>SqlDataAdapter1.Fill(DT);<br>dataGridView1.DataSource = DT;<br>conStr.Close();<span class="hljs-comment">//关闭连接</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 两表之间：根据一个表的字段更新另一个表的字段</title>
    <link href="/%E7%BC%96%E7%A8%8B/SQL/SQL%E4%B8%A4%E8%A1%A8%E4%B9%8B%E9%97%B4%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5.html"/>
    <url>/%E7%BC%96%E7%A8%8B/SQL/SQL%E4%B8%A4%E8%A1%A8%E4%B9%8B%E9%97%B4%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5.html</url>
    
    <content type="html"><![CDATA[<ul><li>写法轻松，更新效率高：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> table1<br><span class="hljs-keyword">set</span> field1<span class="hljs-operator">=</span>table2.field1,<br>field2<span class="hljs-operator">=</span>table2.field2<br><span class="hljs-keyword">from</span> table2<br><span class="hljs-keyword">where</span> table1.id<span class="hljs-operator">=</span>table2.id<br></code></pre></td></tr></table></figure><ul><li>常规方式，另一种写法相当于一个 Left join，以外面的 where 为更新条数，如果不加 where 就是所有记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> table1<br><span class="hljs-keyword">set</span> field1<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> field1 <span class="hljs-keyword">from</span> table2 <span class="hljs-keyword">where</span> table2.id<span class="hljs-operator">=</span>table1.id)<br><span class="hljs-keyword">where</span> table1.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">condition</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以换行 (`\r\n`) 拆分字符串</title>
    <link href="/%E7%BC%96%E7%A8%8B/Csharp/%E4%BB%A5%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%8F%B7%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <url>/%E7%BC%96%E7%A8%8B/Csharp/%E4%BB%A5%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%8F%B7%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h2 id="以换行-r-n-拆分字符串"><a href="#以换行-r-n-拆分字符串" class="headerlink" title="以换行 (\r\n) 拆分字符串"></a>以换行 (<code>\r\n</code>) 拆分字符串</h2><hr><h2 id="字符串数组形式："><a href="#字符串数组形式：" class="headerlink" title="字符串数组形式："></a>字符串数组形式：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-built_in">string</span>[] striparr = strip.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;\r\n&quot;</span> &#125;, StringSplitOptions.None);<br><br>striparr = striparr.Where(s =&gt; !<span class="hljs-built_in">string</span>.IsNullOrEmpty(s)).ToArray();<br></code></pre></td></tr></table></figure><hr><h2 id="List形式："><a href="#List形式：" class="headerlink" title="List形式："></a>List<sting>形式：</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Csharp">List&lt;<span class="hljs-built_in">string</span>&gt; striparr = strip.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;\r\n&quot;</span> &#125;, StringSplitOptions.None).ToList();<br><br>striparr = striparr.Where(s =&gt; !<span class="hljs-built_in">string</span>.IsNullOrEmpty(s)).ToList();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>思源笔记挂件 src-sy-post-publisher 使用教程</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E6%8C%82%E4%BB%B6src-sy-post-publisher%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0/%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E6%8C%82%E4%BB%B6src-sy-post-publisher%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<p>因为目前我只使用了博客园和语雀，所以只写了博客园、语雀和 Typecho 的配置内容。</p><p>‍</p><h2 id="博客园"><a href="#博客园" class="headerlink" title="博客园"></a>博客园</h2><ul><li>博客网址：<a href="https://www.cnblogs.com/博客设置">https://www.cnblogs.com/博客设置</a> - 设置 - 博客地址/</li><li>账号：博客设置 - 设置 - 其他设置-MetaWeblog 登录名</li><li>密码/Token: 博客设置 - 设置 - 其他设置-MetaWeblog 访问令牌</li><li>API 地址：博客设置 - 设置 - 其他设置-MetaWeblog 访问地址</li><li>预览规则：默认即可</li></ul><p>​<img src="https://image.loufengkai.top/2023/01/mmexport1672997099481.png" alt="博客地址" title="博客地址">​</p><p>​<img src="https://image.loufengkai.top/2023/01/mmexport1672998056357.png" alt="MetaWeblog 登录名、访问令牌、访问地址" title="MetaWeblog 登录名、访问令牌、访问地址">​</p><p>‍</p><hr><p>‍</p><h2 id="语雀"><a href="#语雀" class="headerlink" title="语雀"></a>语雀</h2><p>语雀只需要配置用户名和鉴权 token 即可</p><ul><li>用户名：账户设置 - 账户管理 - 个人路径“<a href="https://www.yuque.com/”后面的内容">https://www.yuque.com/”后面的内容</a></li><li>鉴权 token：点击 <a href="https://www.yuque.com/settings/tokens" title="Token 生成地址">Token 生成地址</a>，权限给 <code>修改和读取你的知识库</code> ​ 和 <code>修改和读取你的文档</code> ​ 即可</li></ul><p>​<img src="https://image.loufengkai.top/2023/01/mmexport1672997913652.png" alt="用户名" title="用户名">​</p><p>​<img src="https://image.loufengkai.top/2023/01/mmexport1672997915913.png" alt="Token" title="Token">​</p><p>‍</p><hr><p>‍</p><h2 id="Typecho"><a href="#Typecho" class="headerlink" title="Typecho"></a>Typecho</h2><ul><li>博客地址：为自己 Typecho 网站地址</li><li>账户：为登录博客后台登录账户</li><li>密码/Token：登录博客后台账户的密码</li><li>API 地址：博客网址/index.php/action/xmlrpc</li><li>预览规则：/index.php/archives/[postid]</li></ul><p>​<img src="https://image.loufengkai.top/2023/01/Typecho%E8%AE%BE%E7%BD%AE.png" alt="Typecho 设置" title="Typecho 设置">​</p><p>‍</p>]]></content>
    
    
    
    <tags>
      
      <tag>思源笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
