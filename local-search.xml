<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用 Docker 镜像及生成脚本</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/%E5%B8%B8%E7%94%A8Docker%E9%95%9C%E5%83%8F%E5%8F%8A%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/%E5%B8%B8%E7%94%A8Docker%E9%95%9C%E5%83%8F%E5%8F%8A%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC.html</url>
    
    <content type="html"><![CDATA[<h1 id="常用-Docker-镜像及生成脚本"><a href="#常用-Docker-镜像及生成脚本" class="headerlink" title="常用 Docker 镜像及生成脚本"></a>常用 Docker 镜像及生成脚本</h1><ul><li>思源笔记</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-comment">## 创建文件夹</span><br>mkdir siyuan/workspace<br><span class="hljs-comment">## 生成命令</span><br>docker <span class="hljs-keyword">run</span><span class="language-bash"> </span><br> --name siyuan -it -d  <br> --restart=always <br> -e LANG=zh_CN.UTF-<span class="hljs-number">8</span><br> -e LC_ALL=zh_CN.UTF-<span class="hljs-number">8</span><br> -v /siyuan/workspace:/siyuan/workspace <br> -p <span class="hljs-number">6806</span>:<span class="hljs-number">6806</span> b3log/siyuan:latest<br> --workspace=/siyuan/workspace <span class="hljs-comment">#工作空间</span><br> -accessAuthCode password <span class="hljs-comment"># 授权码</span><br></code></pre></td></tr></table></figure><ul><li>vaultwarden/server</li></ul><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs docker">docker <span class="hljs-keyword">run</span><span class="language-bash"> -d --name=bitwarden  -e WEBSOCKET_ENABLED=<span class="hljs-literal">true</span> -e LOG_FILE=/data/bitwarden.log  -e ADMIN_TOKEN=<span class="hljs-string">&#x27;密码&#x27;</span>  -p 8080:80 -p 3012:3012 -v /docker/bitwarden/data/:/data/ --restart=always  vaultwarden/server:latest</span><br></code></pre></td></tr></table></figure><p>  ‍</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过宝塔面板和 Nginx 开启 Docker 容器 HTTPS 访问</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/%E9%80%9A%E8%BF%87%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%92%8CNginx%E5%BC%80%E5%90%AFDocker%E5%AE%B9%E5%99%A8HTTPS%E8%AE%BF%E9%97%AE.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/%E9%80%9A%E8%BF%87%E5%AE%9D%E5%A1%94%E9%9D%A2%E6%9D%BF%E5%92%8CNginx%E5%BC%80%E5%90%AFDocker%E5%AE%B9%E5%99%A8HTTPS%E8%AE%BF%E9%97%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="通过宝塔面板和-Nginx-开启-Docker-容器-HTTPS-访问"><a href="#通过宝塔面板和-Nginx-开启-Docker-容器-HTTPS-访问" class="headerlink" title="通过宝塔面板和 Nginx 开启 Docker 容器 HTTPS 访问"></a>通过宝塔面板和 Nginx 开启 Docker 容器 HTTPS 访问</h1><h2 id="部署静态网站"><a href="#部署静态网站" class="headerlink" title="部署静态网站"></a>部署静态网站</h2><blockquote><p>不需要数据库，php 版本选择静态</p></blockquote><h2 id="申请-SSL-证书"><a href="#申请-SSL-证书" class="headerlink" title="申请 SSL 证书"></a>申请 SSL 证书</h2><blockquote><p>选择强制开启 https</p></blockquote><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><blockquote><p>注释掉下列代码</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs nginx"> <span class="hljs-comment">#location ~ .*\.(gif|jpg|jpeg|png|bmp|swf)$</span><br> <span class="hljs-comment">#&#123;</span><br> <span class="hljs-comment">#    expires      30d;</span><br> <span class="hljs-comment">#    error_log /dev/null;</span><br> <span class="hljs-comment">#    access_log /dev/null;</span><br> <span class="hljs-comment">#&#125;</span><br><br><span class="hljs-comment"># location ~ .*\.(js|css)?$</span><br><span class="hljs-comment"># &#123;</span><br><span class="hljs-comment">#     expires      12h;</span><br><span class="hljs-comment">#     error_log /dev/null;</span><br><span class="hljs-comment">#     access_log /dev/null;</span><br><span class="hljs-comment"># &#125;</span><br></code></pre></td></tr></table></figure><blockquote><p>添加配置文件</p></blockquote><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">location</span> /&#123;<br>    <span class="hljs-attribute">proxy_pass</span> http://127.0.0.1: 端口号/;<br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^/(.*)$</span> /<span class="hljs-variable">$1</span> <span class="hljs-literal">break</span>;<br>    <span class="hljs-attribute">proxy_redirect</span> <span class="hljs-literal">off</span>;<br>    <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Host <span class="hljs-variable">$host</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto <span class="hljs-variable">$scheme</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Real-IP <span class="hljs-variable">$remote_addr</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Upgrade-Insecure-Requests <span class="hljs-number">1</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto https;<br>    <span class="hljs-attribute">proxy_set_header</span> Upgrade <span class="hljs-variable">$http_upgrade</span>;<br>    <span class="hljs-attribute">proxy_set_header</span> Connection upgrade;<br>  &#125;<br></code></pre></td></tr></table></figure><p>  ‍</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP｜GET 和 POST 区别</title>
    <link href="/%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C/HTTP%EF%BD%9CGET%20%E5%92%8C%20POST%20%E5%8C%BA%E5%88%AB.html"/>
    <url>/%E7%BC%96%E7%A8%8B/%E7%BD%91%E7%BB%9C/HTTP%EF%BD%9CGET%20%E5%92%8C%20POST%20%E5%8C%BA%E5%88%AB.html</url>
    
    <content type="html"><![CDATA[<h2 id="HTTP-｜-GET-和-POST-区别"><a href="#HTTP-｜-GET-和-POST-区别" class="headerlink" title="HTTP ｜ GET 和 POST 区别"></a>HTTP ｜ GET 和 POST 区别</h2><p>​<img src="https://upload-images.jianshu.io/upload_images/5219651-7c744cff9d8be1b4.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="">​</p><blockquote><p>最近在看《HTTP 权威指南》这本书，对 HTTP 协议有了更深一层的了解。</p><p>在我们面试过程中关于 HTTP 协议有两个经典的面试题：</p><ol><li><p>谈谈 HTTP 中 GET 与 POST 的区别。</p></li><li><p>在浏览器中输入 URL 到整个页面显示在用户面前时这个过程中到底发生了什么。</p></li></ol><p>今天我就先谈谈第一个问题。</p></blockquote><p><strong>一、最普遍的答案</strong></p><p>我们在 Google 或百度上搜索这个问题时，得到最多的答案就是如下三点，而这似乎也成为了“标准答案”，其实这个答案有待商榷。</p><ol><li><p>GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 BODY 中。</p></li><li><p>GET 方式提交的数据有长度限制，则 POST 的数据则可以非常大。</p></li><li><p>POST 比 GET 安全，因为数据在地址栏上不可见。</p></li></ol><p><strong>二、“标准答案”其实是错的</strong></p><blockquote><ol><li>GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 BODY 中</li></ol></blockquote><p>GET 和 POST 是由 HTTP 协议定义的。在 HTTP 协议中，Method 和 Data（URL，Body，Header）是正交的两个概念，也就是说，使用哪个 Method 与应用层的数据如何传输是没有相互关系的。</p><p>HTTP 没有要求，如果 Method 是 POST 数据就要放在 BODY 中。也没有要求，如果 Method 是 GET，数据（参数）就一定要放在 URL 中而不能放在 BODY 中。</p><p>那么，网上流传甚广的这个说法是从何而来的呢？我在 HTML 标准中，找到了相似的描述。这和网上流传的说法一致。但是这只是 HTML 标准对 HTTP 协议的用法的约定。怎么能当成 GET 和 POST 的区别呢？</p><p>而且，现代的 Web Server 都是支持 GET 中包含 BODY 这样的请求。虽然这种请求不可能从浏览器发出，但是现在的 Web Server 又不是只给浏览器用，已经完全地超出了 HTML 服务器的范畴了。</p><blockquote><ol><li>GET 方式提交的数据有长度限制，则 POST 的数据则可以非常大</li></ol></blockquote><p>先说结论：HTTP 协议对 GET 和 POST 都没有对长度的限制。HTTP 协议明确地指出了，HTTP 头和 Body 都没有长度的要求。</p><p>首先是”GET 方式提交的数据有长度限制”，如果我们使用 GET 通过 URL 提交数据，那么 GET 可提交的数据量就跟 URL 的长度有直接关系了。而实际上，URL 不存在参数上限的问题，HTTP 协议规范没有对 URL 长度进行限制。这个限制是特定的浏览器及服务器对它的限制。IE 对 URL 长度的限制是 2083 字节 (2K+35)。对于其他浏览器，如 Netscape、FireFox 等，理论上没有长度限制，其限制取决于操作系统的支持。</p><p>注意这个限制是整个 URL 长度，而不仅仅是你的参数值数据长度。</p><p>POST 也是一样，POST 是没有大小限制的，HTTP 协议规范也没有对 POST 数据进行大小限制，起限制作用的是服务器的处理程序的处理能力。</p><p>当然，我们常说 GET 的 URL 会有长度上的限制这个说法是怎么回事呢？虽然这个不是 GET 和 POST 的本质区别，但是我们也可以说说导致 URL 长度限制的两方面的原因：</p><ol><li><p>浏览器。早期的浏览器会对 URL 长度做限制。而现在的具体限制是怎么样的，我自己没有亲测过，就不复制网上的说法啦。</p></li><li><p>服务器。URL 长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个 M 大小的 URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，告诉服务器 Content-Length 是一个很大的数，然后只给服务器发一点儿数据，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给 URL 长度加限制。但是这个限制是针对所有 HTTP 请求的，与 GET、POST 没有关系。</p></li></ol><blockquote><ol><li>POST 比 GET 安全，因为数据在地址栏上不可见</li></ol></blockquote><p>这个说法其实也是基于上面的 1，2 两点的基础上来说的，我觉得没什么问题，但是需要明白为什么使用 GET 在地址栏上就不安全了，以及还有没有其他原因说明“POST 比 GET 安全”。</p><p>通过 GET 提交数据，用户名和密码将明文出现在 URL 上，因为登录页面有可能被浏览器缓存，其他人查看浏览器的历史纪录，那么别人就可以拿到你的账号和密码了，除此之外，使用 GET 提交数据还可能会造成 Cross-site request forgery 攻击。</p><p><strong>三、我的理解</strong></p><p>“1. GET 使用 URL 或 Cookie 传参，而 POST 将数据放在 BODY 中”，这个是因为 HTTP 协议用法的约定。并非它们的本身区别。</p><p>“2. GET 方式提交的数据有长度限制，则 POST 的数据则可以非常大”，这个是因为它们使用的操作系统和浏览器设置的不同引起的区别。也不是 GET 和 POST 本身的区别。</p><p>“3. POST 比 GET 安全，因为数据在地址栏上不可见”，这个说法没毛病，但依然不是 GET 和 POST 本身的区别。</p><p>虽然这三点不是它们的本身区别，但至少是它们在使用上的区别，所以我在面试这个问题时，如果面试者能够回答上面三点我基本会给个及格分。那么你想不想要更高的分数？</p><p><strong>四、终极区别</strong></p><p>GET 和 POST 最大的区别主要是 GET 请求是幂等性的，POST 请求不是。这个是它们本质区别，上面的只是在使用上的区别。</p><blockquote><p>什么是幂等性？幂等性是指一次和多次请求某一个资源应该具有同样的副作用。简单来说意味着对同一 URL 的多个请求应该返回同样的结果。</p><p>关于幂等性看我评论上推荐的一篇文章。</p></blockquote><p>正因为它们有这样的区别，所以不应该且不能用 get 请求做数据的增删改这些有副作用的操作。因为 get 请求是幂等的，在网络不好的隧道中会尝试重试。如果用 get 请求增数据，会有重复操作的风险，而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用 get 请求去做增操作）。</p><p>你是一位道具师，演员在拍电影时大家都约定俗成在对打时用假抢（无杀伤力），在打靶时用气枪（有杀伤力），而你是个异类的道具师，你在对打时把演员的假抢换成了气枪。..</p><p><strong>五、我的建议</strong></p><p>如果面试官问你这个问题时，我建议你说出上面三点，同时要说明那三点是它们在使用上的区别，当然也要把它们的终极区别给说出来。</p><p>PS：曾经有一个研读了 HTTP 协议的人去一家公司面试，面试官问他这个问题时，他回答“GET 是用于获取数据的，POST 一般用于将数据发给服务器。其他 GET 和 POST 没什么区别”，于是被刷了。</p><p>因为有些面试官心中也只有那一个“标准答案”。</p><hr><p>我每次面试都会问这个问题，你知道怎么回答了吗？</p>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E9%85%8D%E7%BD%AE.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E9%85%8D%E7%BD%AE.html</url>
    
    <content type="html"><![CDATA[<h1 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h1><h2 id="Git-config-的全局配置"><a href="#Git-config-的全局配置" class="headerlink" title="Git config 的全局配置"></a>Git config 的全局配置</h2><p>全局设置有两种方式，<strong>命令方式</strong>  和  <strong>配置文件方式</strong>，两种方式选择任意一种，都可以配置全局 git 项目提交 git 信息的账号及邮箱。</p><h3 id="命令方式"><a href="#命令方式" class="headerlink" title="命令方式"></a>命令方式</h3><p>在 git 服务器中，任意非  <strong>本地 git repo</strong>  中，使用以下命令配置全局配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config --global user.name <span class="hljs-string">&quot;your-username&quot;</span><br>git config --global user.email <span class="hljs-string">&quot;your-email-address&quot;</span><br></code></pre></td></tr></table></figure><h3 id="配置文件方式"><a href="#配置文件方式" class="headerlink" title="配置文件方式"></a>配置文件方式</h3><p>编辑  <strong>〜/.gitconfig</strong>，其内容与  <strong>.git/config</strong>  文件中的内容相同，即将  <strong>[user]</strong>  部分信息添加至  <strong>〜/.gitconfig</strong>  文件中，内容如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">[user]<br>    name = your-username<br>    email = your-email-address<br></code></pre></td></tr></table></figure><p>保存并退出。任意非  <strong>本地 git repo</strong>  中，在使用以下命令查看是否配置成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git config user.name<br><br>git config user.email<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用 Git 同时上传代码到 GitHub 和 Coding</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E7%94%A8%20Git%20%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0%20GitHub%20%E5%92%8C%20Coding.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/%E7%94%A8%20Git%20%E5%90%8C%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%BB%A3%E7%A0%81%E5%88%B0%20GitHub%20%E5%92%8C%20Coding.html</url>
    
    <content type="html"><![CDATA[<p>发现最近网站的访问速度并不理想，因为当时只托管在了 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fgithub.com%2F">GitHub</a> 上，GitHub 的服务器在国外，所以导致国内访问服务器的时间比较长。</p><p>解决方法就是把网站同时托管在国内的 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fcoding.net%2F">Coding</a> 上，正好他们也提供了 pages 服务。让国外解析到 GitHub 的服务器上，国内解析到 Coding 的服务器上，这样无论是在国内，还是再国外，网站的访问速度都会大幅提升。</p><p>所以就有了这次的踩坑经历，用 Git 同时管理并 push 到两个远程仓库。</p><p>废话不多说，下面直接上干货。</p><h2 id="创建远程仓库"><a href="#创建远程仓库" class="headerlink" title="创建远程仓库"></a>创建远程仓库</h2><p>先在 Coding 和 GitHub 上创建仓库，为了避免错误，不要初始化 README，license，或者 gitignore 文件</p><p><strong>GitHub</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-5d5c9ed21c7d7af4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-4b228404fc055409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt=""></p><p><strong>Coding</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-4572446e7a7d6e89.png" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-7512db0635a81765.png" alt=""></p><p>‍</p><h2 id="进入本地项目"><a href="#进入本地项目" class="headerlink" title="进入本地项目"></a>进入本地项目</h2><p>打开终端，进入项目目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 你的本地项目地址<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-d37b2fb04577e9f1.png" alt=""></p><p>‍</p><h2 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">git <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-c0a9250aa410bac4.png" alt=""></p><p>‍</p><h2 id="删除已关联的名为-origin-的远程库"><a href="#删除已关联的名为-origin-的远程库" class="headerlink" title="删除已关联的名为 origin 的远程库"></a>删除已关联的名为 origin 的远程库</h2><p>使用多个远程库时，要注意 Git 给远程库起的默认名称是 origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库，首先要删除已关联的名为 origin 的远程库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote <span class="hljs-built_in">rm</span> origin<br></code></pre></td></tr></table></figure><p>如果输入后显示如下图所示：fatal: No such remote: origin ，说明你本地项目没有已关联的名为 origin 的远程库，那么你可以忽略此步。</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-2c65e0805ade5cb0.png" alt=""></p><p>‍</p><h2 id="配置-Git-用户名和邮箱"><a href="#配置-Git-用户名和邮箱" class="headerlink" title="配置 Git 用户名和邮箱"></a>配置 Git 用户名和邮箱</h2><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name &quot;fengkai.lou&quot;<br><br>git config <span class="hljs-keyword">user</span>.email &quot;loufengkai@qq.com&quot;<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-6e444810e347ae6d.png" alt=""></p><p>‍</p><h2 id="关联-GitHub-远程库"><a href="#关联-GitHub-远程库" class="headerlink" title="关联 GitHub 远程库"></a>关联 GitHub 远程库</h2><p>这里我用的是 SSH 的方式，至于如何管理并配置 SSH，你可以参考 <a href="https://links.jianshu.com/go?to=https%3A%2F%2Fwww.lien.run%2F20190805%2Fmore-ssh">这里</a></p><p>注意，远程库的名称叫 github，不叫 origin 了！</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">git remote <span class="hljs-keyword">add</span><span class="language-bash"> github git@github.com:isArtJay/test.git</span><br></code></pre></td></tr></table></figure><p>‍</p><h2 id="关联-Coding-远程库"><a href="#关联-Coding-远程库" class="headerlink" title="关联 Coding 远程库"></a>关联 Coding 远程库</h2><p>同样注意，远程库的名称叫 coding，不叫 origin 了！</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git remote add coding git@e.coding.net:liencn<span class="hljs-regexp">/lien/</span>test.git<br></code></pre></td></tr></table></figure><p>现在，我们用 <code>git remote -v ​</code>​ 查看远程库信息，可以看到两个远程库：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-470c5bc31088fbe1.png" alt=""></p><p>‍</p><h2 id="添加文件到本地仓库"><a href="#添加文件到本地仓库" class="headerlink" title="添加文件到本地仓库"></a>添加文件到本地仓库</h2><p>添加文件到本地仓库，其中 <strong>.</strong> 的意思是本地项目目录中的所有文件：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git <span class="hljs-built_in">add</span> .<br></code></pre></td></tr></table></figure><p>‍</p><h2 id="提交文件"><a href="#提交文件" class="headerlink" title="提交文件"></a>提交文件</h2><p>-m 后的参数是你的提交信息，可以随意填写：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">git</span> commit -m <span class="hljs-string">&quot;First commit&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-8af0c43cd00d059d.png" alt=""></p><p>‍</p><h2 id="push-到远程仓库"><a href="#push-到远程仓库" class="headerlink" title="push 到远程仓库"></a>push 到远程仓库</h2><p>如果要 push 到 GitHub，使用命令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> github master<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-eb8cd1e036944079.png" alt=""></p><p>如果要 push 到 Coding，使用命令：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade">git <span class="hljs-built_in">push</span> coding master<br></code></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/22090397-2fe4a0f2be7b1d9c.png" alt=""></p><p>‍</p><h2 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h2><p>可以看到我们已经将本地项目推送到了的 GitHub 仓库和 Coding 仓库：</p><p><strong>GitHub</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-b858c1f96a1a9c33.png" alt=""></p><p><strong>Coding</strong> ：</p><p><img src="https://upload-images.jianshu.io/upload_images/22090397-362ae9c9b12eef73.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>GitHub</tag>
      
      <tag>Coding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 版思源笔记使用 Dark+ 主题，无法显示“霞鹜文楷等宽”字体的解决方式</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E7%89%88%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8Dark+%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E2%80%9C%E9%9C%9E%E9%B9%9C%E6%96%87%E6%A5%B7%E7%AD%89%E5%AE%BD%E2%80%9D%E5%AD%97%E4%BD%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E7%89%88%E6%80%9D%E6%BA%90%E7%AC%94%E8%AE%B0%E4%BD%BF%E7%94%A8Dark+%E4%B8%BB%E9%A2%98%EF%BC%8C%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E2%80%9C%E9%9C%9E%E9%B9%9C%E6%96%87%E6%A5%B7%E7%AD%89%E5%AE%BD%E2%80%9D%E5%AD%97%E4%BD%93%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F.html</url>
    
    <content type="html"><![CDATA[<p>在 Docker 版思源笔记中使用 Dark+ 主题时，编辑器的字体与 Dark+ 中主题预览的字体不一致。</p><p>此问题咨询了思源笔记官方得到是回复是“官方暂时不考虑 Docker 版的编辑器暂不考虑支持自定义字体”。</p><p>咨询 Dark+ 主题的制作者得到的回复是“思源笔记官方做了限制”。</p><p>Dark+ 主题的制作者提供了一个解决方案如下</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.b3-typography</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-class">.b3-typography--default</span>),<br><span class="hljs-selector-class">.protyle-wysiwyg</span>,<br><span class="hljs-selector-class">.protyle-title</span>,<br><span class="hljs-selector-class">.protyle-title__input</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;霞鹜文楷等宽&quot;</span>, <span class="hljs-string">&quot;quote&quot;</span>, <span class="hljs-string">&quot;Helvetica Neue&quot;</span>, <span class="hljs-string">&quot;Luxi Sans&quot;</span>, <span class="hljs-string">&quot;DejaVu Sans&quot;</span>, <span class="hljs-string">&quot;Hiragino Sans GB&quot;</span>, <span class="hljs-string">&quot;Microsoft Yahei&quot;</span>, sans-serif, <span class="hljs-string">&quot;Apple Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Emoji&quot;</span>, <span class="hljs-string">&quot;Noto Color Emoji&quot;</span>, <span class="hljs-string">&quot;Segoe UI Symbol&quot;</span>, <span class="hljs-string">&quot;Android Emoji&quot;</span>, <span class="hljs-string">&quot;EmojiSymbols&quot;</span> <span class="hljs-meta">!important</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装 MSSQL</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MSSQL.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MSSQL.html</url>
    
    <content type="html"><![CDATA[<h1 id="Docker-安装-MSSQL"><a href="#Docker-安装-MSSQL" class="headerlink" title="Docker 安装 MSSQL"></a>Docker 安装 MSSQL</h1><h2 id="群晖安装"><a href="#群晖安装" class="headerlink" title="群晖安装"></a>群晖安装</h2><ol><li>下载 MSSQL 镜像</li></ol><ul><li>由于在群晖 Docker 的注册表中无法搜索到微软官方的镜像，因此这里我们在 SSH 客户端通过 bash 命令来下载镜像。</li><li>首先，在群晖主页 - 控制面板 - 连接性 - 终端机和 SNMP-终端机选项卡中启动 SSH 功能，如下图：<br><img src="https://image.loufengkai.top/siyuan/clipboard_20230208_121940.png" alt="启用群晖的 SSH 功能"></li><li>然后通过 SSH 客户端连接至群晖系统，这里我用的是 Tabby Terminal，然后执行以下命令：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker pull mcr.microsoft.com/mssql/server:2022-latest<br></code></pre></td></tr></table></figure><p>执行结果如下图：<br><img src="https://image.loufengkai.top/siyuan/clipboard_20230208_122254.png" alt="下载 MSSQL 镜像"></p><ul><li>回到群晖主界面-Docker-映像，就可以看到这个镜像了，如下图：<br><img src="https://image.loufengkai.top/siyuan/clipboard_20230208_122603.png" alt="群晖主界面-Docker-映像"></li></ul><ol><li>创建持久化挂载目录并设置目录权限<br>如下图创建目录：<br><img src="https://image.loufengkai.top/siyuan/202302080035215.png" alt="创建目录"><br>并鼠标右键点击 mssqlserver-属性，新增用户权限，这里为了简化，把 mssqlserver 这个目录及子目录的所有权限设置给 EveryOne，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080039350.png" alt="授予权限"></li><li>启动 mcr.microsoft.com/mssql/server:2022-latest 镜像</li></ol><ul><li>从群晖主页-Docker-映像列表中找到 mssql/server，然后点击上面的启动按钮，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080044874.png" alt="创建容器"><br>在启动对话框中输入容器名称、设置资源限制，重启自动启动。</li><li>然后点击“高级设置”按钮增加 2 个环境变量，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080050483.png" alt="设置环境变量"><blockquote><p>ACCEPT_EULA 表示同意微软的许可协议，值必须是 Y。<br>MSSQL_SA_PASSWORD 表示 sa 账户的密码，必须是强安全规则的，大小写字母特殊字符数字切长度大于等于 8</p></blockquote></li><li>点击“保存”按钮，然后点击“下一步”，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080115377.png" alt="保存"><br>这里是进行主机端口与容器端口进行映射。</li><li>点击‘下一步“按钮，如下图：</li><li><img src="https://image.loufengkai.top/siyuan/202302080054885.png" alt="映射端口"><br>点击”添加文件夹“，进行持久化挂载目录映射，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080056913.png" alt="挂载目录映射"></li><li>点击”下一步“，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080056964.png" alt="摘要"></li><li>点击”完成“按钮，容器就会启动，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080057305.png" alt="启动容器"></li></ul><ol><li>在工作电脑访问 Docker 中的 SQL Server</li></ol><ul><li>可以在工作电脑上安装一个 SSMS，启动后，输入连接参数，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080115976.png" alt="输入连接参数"></li><li>点击”连接“，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080116784.png" alt="连接群晖上的 MSSQL"></li><li><p>新建查询，查看一下数据库的版本，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080118909.png" alt="查询"></p></li><li><p>创建一个数据库，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080120450.png" alt="创建数据库"></p></li><li>在群晖 File Station 中查看数据库文件，如下图：<br><img src="https://image.loufengkai.top/siyuan/202302080122914.png" alt="查看数据库文件"></li></ul><h2 id="非群晖安装"><a href="#非群晖安装" class="headerlink" title="非群晖安装"></a>非群晖安装</h2><ol><li>从 Microsoft 容器注册表中请求 SQL Server 2022 (16.x) Linux 容器映像。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker pull mcr.microsoft.com/mssql/server:2022-latest<br></code></pre></td></tr></table></figure><ol><li>要使用 Docker 运行 Linux 容器映像，可以从 Bash Shell 或提升的 PowerShell 命令提示符使用以下命令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker run -e <span class="hljs-string">&quot;ACCEPT_EULA=Y&quot;</span> -e <span class="hljs-string">&quot;MSSQL_SA_PASSWORD=&lt;YourStrong@Passw0rd&gt;&quot;</span> \<br>   -p 1433:1433 --name sql1 --hostname sql1 \<br>   -d \<br>   mcr.microsoft.com/mssql/server:2022-latest<br></code></pre></td></tr></table></figure><blockquote><p>密码应符合 SQL Server 默认密码策略，否则容器无法设置 SQL Server，将停止工作。默认情况下，密码必须为至少八个字符且包含以下四种字符中的三种：大写字母、小写字母、十进制数字、符号。</p></blockquote><p>下表对前一个  <code>docker run</code>  示例中的参数进行了说明：</p><div class="table-container"><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><strong>-e “ACCEPT_EULA=Y”</strong></td><td style="text-align:left">将  <code>ACCEPT_EULA</code>变量设置为任意值，以确认接受最终用户许可协议。SQL Server 映像的必需设置。</td><td></td></tr><tr><td style="text-align:left"><strong>-e “MSSQL_SA_PASSWORD=<a href="&#109;&#97;&#105;&#x6c;&#x74;&#x6f;&#x3a;&#x59;&#111;&#117;&#x72;&#83;&#x74;&#x72;&#111;&#110;&#x67;&#x40;&#x50;&#x61;&#x73;&#x73;&#x77;&#48;&#x72;&#x64;">&#x59;&#111;&#117;&#x72;&#83;&#x74;&#x72;&#111;&#110;&#x67;&#x40;&#x50;&#x61;&#x73;&#x73;&#x77;&#48;&#x72;&#x64;</a>“</strong></td><td style="text-align:left">指定至少包含 8 个字符且符合  <a href="https://learn.microsoft.com/zh-cn/sql/relational-databases/security/password-policy?view=sql-server-ver16">SQL Server 密码要求</a> 的强密码。SQL Server 映像的必需设置。</td><td></td></tr><tr><td style="text-align:left"><strong>-e “MSSQL<em>COLLATION=&lt;_SQL_Server_collation</em>&gt;”</strong></td><td style="text-align:left">指定自定义 SQL Server 排序规则，而不使用默认值  <code>SQL_Latin1_General_CP1_CI_AS</code>。</td></tr><tr><td style="text-align:left"><strong>-p 1433:1433</strong></td><td style="text-align:left">将主机环境中的 TCP 端口（第一个值）映射到容器中的 TCP 端口（第二个值）。在此示例中，SQL Server 侦听容器中的 TCP 1433，此容器端口随后会对主机上的 TCP 端口 1433 公开。</td><td>公开。</td></tr><tr><td style="text-align:left"><strong>—name sql1</strong></td><td style="text-align:left">为容器指定一个自定义名称，而不是使用随机生成的名称。如果运行多个容器，则无法重复使用相同的名称。</td><td></td></tr><tr><td style="text-align:left"><strong>—hostname sql1</strong></td><td style="text-align:left">用于显式设置容器主机名。如果未指定主机名，则主机名默认为容器 ID，这是随机生成的系统 GUID。</td><td></td></tr><tr><td style="text-align:left"><strong>-d</strong></td><td style="text-align:left">在后台运行容器（守护程序）。</td></tr><tr><td style="text-align:left"><strong>mcr.microsoft.com/mssql/server:2022-latest</strong></td><td style="text-align:left">SQL Server Linux 容器映像。</td></tr></tbody></table></div><ol><li>要查看 Docker 容器，请使用  <code>docker ps</code>  命令。</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker ps -a<br></code></pre></td></tr></table></figure><p>应该会看到与下面类似的输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">CONTAINER ID   IMAGE                                        COMMAND                    CREATED         STATUS         PORTS                                       NAMES<br>d4a1999ef83e   mcr.microsoft.com/mssql/server:2022-latest   <span class="hljs-string">&quot;/opt/mssql/bin/perm...&quot;</span>   2 minutes ago   Up 2 minutes   0.0.0.0:1433-&gt;1433/tcp, :::1433-&gt;1433/tcp   sql1<br></code></pre></td></tr></table></figure><ol><li>更改系统管理员密码<br>SA 帐户是安装过程中在 SQL Server 实例上创建的系统管理员。创建 SQL Server 容器后，可以通过在容器中运行中运行  <code>echo $MSSQL_SA_PASSWORD</code>  来发现指定的  <code>MSSQL_SA_PASSWORD</code>环境变量。出于安全考虑，请考虑更改 SA 密码。码。</li></ol><ul><li>选择 SA 用户要使用的强密码。</li><li>使用  <code>docker exec</code>运行 sqlcmd，以使用 Transact-SQL 更改密码。以下示例将从用户输入中读取旧密码和新密码。码。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo docker <span class="hljs-built_in">exec</span> -it sql1 /opt/mssql-tools/bin/sqlcmd \<br>-S localhost -U SA \<br> -P <span class="hljs-string">&quot;<span class="hljs-subst">$(read -sp <span class="hljs-string">&quot;Enter current SA password: &quot;</span>; echo <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;REPLY&#125;</span>&quot;</span>)</span>&quot;</span> \<br> -Q <span class="hljs-string">&quot;ALTER LOGIN SA WITH PASSWORD=\&quot;<span class="hljs-subst">$(read -sp <span class="hljs-string">&quot;Enter new SA password: &quot;</span>; echo <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;REPLY&#125;</span>&quot;</span>)</span>\&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dcoker 安装 Cloudreve 网盘</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Dcoker%E5%AE%89%E8%A3%85Cloudreve%E7%BD%91%E7%9B%98.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Dcoker%E5%AE%89%E8%A3%85Cloudreve%E7%BD%91%E7%9B%98.html</url>
    
    <content type="html"><![CDATA[<h1 id="Dcoker-安装-Cloudreve-网盘"><a href="#Dcoker-安装-Cloudreve-网盘" class="headerlink" title="Dcoker 安装 Cloudreve 网盘"></a>Dcoker 安装 Cloudreve 网盘</h1><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li><p>从群晖套件中安装好 Docker</p></li><li><p>创建共享文件夹，比如名称为<code>dokcer</code></p></li><li><p>在 docker 文件夹下创建<code>cloudreve</code>文件夹</p></li><li><p>在<code>cloudreve</code>文件夹下创建<code>config</code>、<code>db</code>、<code>uploads</code>、<code>avatar</code>四个文件夹</p></li><li><p>创建配置文件，放在<code>config</code>目录下面，内容如下：</p></li></ul><h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><ol><li>下载 Cloudreve 镜像</li></ol><p>打开 Docker，在注册表中搜索<code>cloudreve</code>，选择第一个<code>cloudreve/cloudreve</code>, 并双击下载<br><img src="https://image.loufengkai.top/siyuan/202302081222160.png" alt=""> 2. 下载完成后，从<code>映像</code>中找到镜像，双击开始安装</p><blockquote><p>容器名称随便填，建议为 cloudreve</p></blockquote><p><img src="https://image.loufengkai.top/siyuan/202302081224952.png" alt=""></p><ol><li><p>点击<code>高级设置</code>，开始设置<code>存储空间</code>、<code>端口设置</code>和<code>环境</code></p></li><li><p><code>存储空间</code>需要挂载 4 个目录</p></li></ol><blockquote><ul><li>uploads 对应下载目录</li><li>db 对应数据库目录</li><li>avatar 对应用户头像目录</li><li>config 对应配置目录</li></ul></blockquote><p><img src="https://image.loufengkai.top/siyuan/202302081227639.png" alt=""></p><ol><li><p>端口保持默认的<code>5212</code>即可，改成其他的也行<br><img src="https://image.loufengkai.top/siyuan/202302081225807.png" alt=""></p></li><li><p>以上配置完成后，点击<code>应用</code>回到创建向导页面，继续点击<code>下一步</code>，勾选<code>向导完成后运行此容器</code>，点击<code>完成</code>即可<br><img src="https://image.loufengkai.top/siyuan/202302081229919.png" alt=""></p></li><li><p>获取初始管理员账号和密码</p></li></ol><p>回到 docker 页面，在<code>容器</code>中找到上面创建好的 cloudreve 容器，双击打开，切换到<code>日志</code>页面，可以看到初始管理员账号和密码<br><img src="https://image.loufengkai.top/siyuan/202302081230461.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装 bitwarden</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85bitwarden.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85bitwarden.html</url>
    
    <content type="html"><![CDATA[<blockquote><p>此方法过于麻烦弃用</p></blockquote><h2 id="Docker-安装-bitwarden"><a href="#Docker-安装-bitwarden" class="headerlink" title="Docker 安装 bitwarden"></a>Docker 安装 bitwarden</h2><p>说明：</p><p>bitwarden 是一款开源密码管理器，其衍生版本 docker 镜像名为 bitwarden_rs。</p><p>bitwarden_rs 项目从 v2.21.0 开始，已更名为 Vaultwarden。</p><p>项目地址：<a href="https://github.com/dani-garcia/vaultwarden">https://github.com/dani-garcia/vaultwarden</a></p><p>Ps：文中会使用到 Portainer-Docker 可视化工具进行操作。</p><h2 id="1-安装-Vaultwarden"><a href="#1-安装-Vaultwarden" class="headerlink" title="1. 安装 Vaultwarden"></a>1. 安装 Vaultwarden</h2><p>docker 拉取 bitwarden 镜像</p><pre><code class="hljs">docker pull vaultwarden/server:latest</code></pre><p>创建 bitwarden 容器，8001 端口</p><pre><code class="hljs">docker run -it -d --name vaultwarden -v /data/vaultwarden/data/:/data/ -p 8001:80  --restart=always  vaultwarden/server:latest</code></pre><p>Portainer 中操作如下：</p><p><img src="https://img2022.cnblogs.com/blog/2224398/202203/2224398-20220303145132517-663623153.png" alt=""></p><p><img src="https://img2022.cnblogs.com/blog/2224398/202203/2224398-20220303145153373-2014990969.png" alt=""></p><h2 id="2-安装-acme-sh，使用-Letsencrypt-颁发-SSL-证书"><a href="#2-安装-acme-sh，使用-Letsencrypt-颁发-SSL-证书" class="headerlink" title="2. 安装 acme.sh，使用 Letsencrypt 颁发 SSL 证书"></a>2. 安装 acme.sh，使用 Letsencrypt 颁发 SSL 证书</h2><h3 id="2-1docker-安装-acme-sh"><a href="#2-1docker-安装-acme-sh" class="headerlink" title="2.1docker 安装 acme.sh"></a>2.1docker 安装 acme.sh</h3><p>acme 官方说明文档：<a href="https://github.com/acmesh-official/acme.sh/wiki/">https://github.com/acmesh-official/acme.sh/wiki/</a></p><pre><code class="hljs">docker pull neilpang/acme.sh</code></pre><h3 id="2-2-注册帐户"><a href="#2-2-注册帐户" class="headerlink" title="2.2 注册帐户"></a>2.2 注册帐户</h3><p>&lt;注意：从 acme.sh v3.0.0 开始，acme.sh 使用 Zerossl 视为默认 ca，您必须先注册帐户（一次），然后才能颁发新证书。&gt;</p><p>ZeroSSL 申请 EAB Credentials for ACME Clients：<a href="https://app.zerossl.com/developer">https://app.zerossl.com/developer</a></p><pre><code class="hljs">docker  run  --rm  -it  -v  &quot;/data/acme.sh/out/&quot;:/acme.sh  neilpang/acme.sh  --register-account  --server zerossl --eab-kid  AxxxxQ --eab-hmac-key  5xxxxQ注册成功后会显示一个 ACCOUNT_THUMBPRINT 和 ZeroSSL-CA--rm 参数表示运行停止后立即删除该容器</code></pre><p>如下图：</p><p><img src="https://img2022.cnblogs.com/blog/2224398/202203/2224398-20220303145206783-395889605.png" alt=""></p><h3 id="2-3-修改默认-CA"><a href="#2-3-修改默认-CA" class="headerlink" title="2.3 修改默认 CA"></a>2.3 修改默认 CA</h3><p>acme.sh 的初始 CA 为 ZeroSSL，如果想使用 letsencrypt，请用以下代码</p><pre><code class="hljs">docker  run  --rm  -it  -v  &quot;/data/acme.sh/out/&quot;:/acme.sh  neilpang/acme.sh  --set-default-ca  --server letsencrypt</code></pre><h3 id="2-4-颁发证书"><a href="#2-4-颁发证书" class="headerlink" title="2.4 颁发证书"></a>2.4 颁发证书</h3><p>Godaddy 申请 API Key Management：<a href="https://developer.godaddy.com/keys">https://developer.godaddy.com/keys</a></p><pre><code class="hljs">docker  run  --rm  -it  -v  &quot;/data/acme.sh/out/&quot;:/acme.sh  -e  GD_Key=&quot;exxxK_3xxxH&quot;  -e  GD_Secret=&quot;Vxxxh&quot;  neilpang/acme.sh  --issue  --dns  dns_gd  -d  example.com  -d  *.example.com--rm 参数表示运行停止后删除该容器，参数 v 表示容器路径映射到本地路径，参数-e 中 GD_Key 和 GD_Secret 表示是 Godaddy 的域名。成功之后，证书会保存在 out 文件夹，也可以指定路径，修改上面第一行 `&quot;/data/acme.sh/out/&quot;`，改为你想要保存的路径即可zerossl 的 eab-kid 和 eab-hmac-key，godaddy 的 GD_Key 和 GD_Secret 有效期不长。有时候出现“docker: invalid reference format.”时，更新上述参数即可。&#39;</code></pre><h3 id="2-5-其他操作"><a href="#2-5-其他操作" class="headerlink" title="2.5 其他操作"></a>2.5 其他操作</h3><pre><code class="hljs">docker run --rm  -it -v &quot;/data/acme.sh/out/&quot;:/acme.sh neilpang/acme.sh --revoke  -d example.com$ acme.sh --renew -d example.com --force</code></pre><h2 id="3-配置-nginx-反向代理"><a href="#3-配置-nginx-反向代理" class="headerlink" title="3. 配置 nginx 反向代理"></a>3. 配置 nginx 反向代理</h2><h3 id="3-1docker-安装-nginx"><a href="#3-1docker-安装-nginx" class="headerlink" title="3.1docker 安装 nginx"></a>3.1docker 安装 nginx</h3><pre><code class="hljs">docker  pull  nginx</code></pre><h3 id="3-2-运行-nginx，把-nginx-容器的端口映射到本地端口"><a href="#3-2-运行-nginx，把-nginx-容器的端口映射到本地端口" class="headerlink" title="3.2 运行 nginx，把 nginx 容器的端口映射到本地端口"></a>3.2 运行 nginx，把 nginx 容器的端口映射到本地端口</h3><p>把 nginx 容器的目录映射到本地的目录，设置重启策略</p><pre><code class="hljs">docker  run  -it  -d  -v  &quot;/data/nginx/config/&quot;:/config/  -v &quot;/data/nginx/www/html/&quot;:/usr/share/nginx/html/ -v &quot;/data/nginx/download/&quot;:/opt/download/ -p  80:80  -p 443:443  -p  3012:3012  --name nginx  --restart=always  nginx</code></pre><h3 id="3-3-把-acme-sh-生成的证书上传到-nginx-服务目录下"><a href="#3-3-把-acme-sh-生成的证书上传到-nginx-服务目录下" class="headerlink" title="3.3 把 acme.sh 生成的证书上传到 nginx 服务目录下"></a>3.3 把 acme.sh 生成的证书上传到 nginx 服务目录下</h3><p>&lt;因为已把’/config’ 目录目录映射到本地，所以只要复制文件到 ‘/data/nginx/‘ 目录下就可以了&gt;</p><pre><code class="hljs">cd /data/acme.sh/out/example.com/cp  example.com.cer  /data/nginx/example.com.cercp example.com.key  /data/nginx/example.com.key</code></pre><h3 id="3-4-创建-web-conf-文件并上传"><a href="#3-4-创建-web-conf-文件并上传" class="headerlink" title="3.4 创建 web.conf 文件并上传"></a>3.4 创建 web.conf 文件并上传</h3><p>把 web.conf 重名为 example.com.conf（自己的域名），上传到容器内 ‘/etc/nginx/conf.d/‘ 目录下</p><pre><code class="hljs">$ docker ps# 查看容器 ID$ docker cp /data/example.com.conf 容器 ID：/etc/nginx/conf.d/example.com.conf# 方法 2$ mv web.conf /data/nginx/download/web.conf$ docker exec -it nginx /bin/bash$ mv /opt/download/web.conf /etc/nginx/conf.d/example.com.conf</code></pre><p>然后重启 nginx 服务。</p><p>此时就可以访问 <a href="https://example.com/">https://example.com</a> 进入 bitwarden 页面，注册使用。</p><p>创建 web.conf 文件</p><pre><code class="hljs">server    &#123;        listen 80;        server_name example.com;  rewrite ^/(.*) https://$server_name/$1 permanent;    &#125;server    &#123;        listen 443 ssl http2;        server_name example.com;        ssl on;        ssl_certificate /config/example.com.cer;        ssl_certificate_key /config/example.com.key;        ssl_session_timeout 5m;        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;        ssl_prefer_server_ciphers on;        ssl_ciphers &quot;EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5&quot;;        ssl_session_cache builtin:1000 shared:SSL:10m;        # ssl_dhparam /etc/nginx/dhparam.pem;  add_header Strict-Transport-Security &quot;max-age=63072000; includeSubdomains; preload&quot;;  add_header X-Frame-Options DENY;  add_header X-Content-Type-Options nosniff;  location / &#123;          proxy_set_header  Host  zheteng.pw;          proxy_pass http://192.168.20.5:8001;          proxy_redirect off;          proxy_set_header X-Real-IP $remote_addr;          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;  &#125;  location /notifications/hub &#123;      proxy_pass http://127.0.0.1:3012;      proxy_set_header Upgrade $http_upgrade;      proxy_set_header Connection &quot;upgrade&quot;;    &#125;    location /notifications/hub/negotiate &#123;      proxy_pass http://192.168.20.5:8001;    &#125; &#125;</code></pre><h2 id="4-certbot-使用"><a href="#4-certbot-使用" class="headerlink" title="4.certbot 使用"></a>4.certbot 使用</h2><h3 id="4-1-安装更新-snap"><a href="#4-1-安装更新-snap" class="headerlink" title="4.1 安装更新 snap"></a>4.1 安装更新 snap</h3><pre><code class="hljs">ubuntu20 自带 snapsudo snap install core; sudo snap refresh core</code></pre><p>4.2 安装 certbot</p><pre><code class="hljs">sudo snap install --classic certbot$ sudo ln -s /snap/bin/certbot /usr/bin/certbot$ sudo certbot --apache$ sudo certbot certonly --apache</code></pre><p>参考链接：</p><p><a href="https://certbot.eff.org/instructions?ws=apache&amp;os=ubuntufocal">https://certbot.eff.org/instructions?ws=apache&amp;os=ubuntufocal</a></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Markdown 语法</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/Markdown%E8%AF%AD%E6%B3%95.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/Markdown%E8%AF%AD%E6%B3%95.html</url>
    
    <content type="html"><![CDATA[<h1 id="Markdown-语法"><a href="#Markdown-语法" class="headerlink" title="Markdown 语法"></a>Markdown 语法</h1><h4 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h4><p><a href="https://link.jianshu.com/?t=http://zh.wikipedia.org/wiki/Markdown">Markdown</a> 是一种轻量级的「标记语言」，它的优点很多，目前也被越来越多的写作爱好者，撰稿者广泛使用。看到这里请不要被「标记」、「语言」所迷惑，Markdown 的语法十分简单。常用的标记符号也不超过十个，这种相对于更为复杂的 HTML 标记语言来说，Markdown 可谓是十分轻量的，学习成本也不需要太多，且一旦熟悉这种语法规则，会有一劳永逸的效果。</p><p><img src="https://image.loufengkai.top/siyuan/202302081152949.png" alt=""></p><p><a href="http://www.ulyssesapp.com">Ulysses for Mac</a></p><h2 id="一，认识-Markdown"><a href="#一，认识-Markdown" class="headerlink" title="一，认识 Markdown"></a>一，认识 Markdown</h2><p>在刚才的导语里提到，Markdown 是一种用来写作的轻量级「标记语言」，它用简洁的语法代替排版，而不像一般我们用的字处理软件 Word 或 Pages 有大量的排版、字体设置。它使我们专心于码字，用「标记」语法，来代替常见的排版格式。例如此文从内容到格式，甚至插图，键盘就可以通通搞定了。目前来看，支持 Markdown 语法的编辑器有很多，包括很多网站（例如 <a href="https://www.jianshu.com/">简书</a>）也支持了 Markdown 的文字录入。Markdown 从写作到完成，导出格式随心所欲，你可以导出 HTML 格式的文件用来网站发布，也可以十分方便的导出 PDF 格式，这种格式写出的简历更能得到 HR 的好感。甚至可以利用 <a href="https://link.jianshu.com/?t=http://www.getcloudapp.com">CloudApp</a> 这种云服务工具直接上传至网页用来分享你的文章，全球最大的轻博客平台 <a href="https://link.jianshu.com/?t=http://te1ee.tumblr.com">Tumblr</a>，也支持 Mou 这类 Markdown 工具的直接上传。</p><h3 id="Markdown-官方文档"><a href="#Markdown-官方文档" class="headerlink" title="Markdown 官方文档"></a>Markdown 官方文档</h3><p>这里可以看到官方的 Markdown 语法规则文档，当然，后文我也会用自己的方式阐述这些语法的具体用法。</p><h3 id="使用-Markdown-的优点"><a href="#使用-Markdown-的优点" class="headerlink" title="使用 Markdown 的优点"></a>使用 Markdown 的优点</h3><ul><li>专注你的文字内容而不是排版样式，安心写作。</li><li>轻松的导出 HTML、PDF 和本身的 .md 文件。</li><li>纯文本内容，兼容所有的文本编辑器与字处理软件。</li><li>随时修改你的文章版本，不必像字处理软件生成若干文件版本导致混乱。</li><li>可读、直观、学习成本低。</li></ul><h3 id="使用-Markdown-的误区"><a href="#使用-Markdown-的误区" class="headerlink" title="使用 Markdown 的误区"></a>使用 Markdown 的误区</h3><p>_We believe that writing is about content, about what you want to say – not about fancy formatting._</p><p>我们坚信写作写的是内容，所思所想，而不是花样格式。<br> — Ulysses for Mac</p><ul><li>Markdown 旨在简洁、高效，也由于 Markdown 的易读易写，人们用不同的编程语言实现了多个版本的解析器和生成器，这就导致了目前不同的 Markdown 工具集成了不同的功能（基础功能大致相同），例如流程图与时序图，复杂表格与复杂公式的呈现，虽然功能的丰富并没有什么本质的缺点，但终归有些背离初衷，何况在编写的过程中很费神，不如使用专业的工具撰写来的更有效率，所以如果你需实现复杂功能，专业的图形界面工具会更加方便。当然，如果你对折腾这些不同客户端对 Markdown 的定制所带来高阶功能感到愉悦的话，那也是无可厚非的。</li></ul><p><img src="https://image.loufengkai.top/siyuan/202302081150498.png" alt=""></p><p><a href="[https://github.com/adrai/flowchart.js](https://github.com/adrai/flowchart.js">flowchart.js on Github（使用 Markdown 绘制流程图）</a>&gt;)</p><h3 id="我该用什么工具？"><a href="#我该用什么工具？" class="headerlink" title="我该用什么工具？"></a>我该用什么工具？</h3><p><img src="https://image.loufengkai.top/siyuan/202302081150169.png" alt=""></p><p>Mou for Mac</p><ul><li>在 Mac OS X 上，我强烈建议你用 <a href="https://link.jianshu.com/?t=http://mouapp.com">Mou</a> 这款免费且十分好用的 Markdown 编辑器，它支持实时预览，既左边是你编辑 Markdown 语言，右边会实时的生成预览效果。不仅如此，Mou 还有一些有趣的偏好设置（Preference），例如主题（Themes）与样式（CSS），它们可以配置出定制化的文本编辑效果与导出效果，如果你对自带的主题与样式不满意还可以到 <a href="https://link.jianshu.com/?t=https://github.com/search?utf8=%E2%9C%93&amp;q=Mou">GitHub</a> 上搜索其它爱好者为 Mou 编写的更多主题样式，导入的方式可以在偏好设置的 Themes 或 CSS 选项中 选择 reload。</li></ul><p><img src="https://image.loufengkai.top/siyuan/202302081151057.png" alt=""></p><p>Mou 的编写与预览窗口</p><p>如果你从事文字工作，我强烈建议你购买 <a href="https://link.jianshu.com/?t=http://www.ulyssesapp.com">Ulysses for Mac</a>，这款软件入围了苹果 Mac App Store 的 The Best of 2013。它支持更多的写作格式、多文档的支持。Mou，iA writer 这些软件都是基于单文档的管理方式，而 Ulysses 支持 Folder、Filter 的管理，一个 Folder 里面可以创建多个 Sheet，Sheet 之间也可以进行 Combine 处理。</p><p><img src="https://image.loufengkai.top/siyuan/202302081151662.png" alt=""></p><p>Mac 上一些 Markdown 编辑器</p><ul><li>由于笔者很少接触 Windows，Windows 下的 Markdown 没有过多涉猎，经朋友介绍，有两款还算不错，一款叫做 <a href="https://link.jianshu.com/?t=http://www.markdownpad.com">MarkdownPad</a> ，另一款叫做 <a href="https://link.jianshu.com/?t=http://code52.org/DownmarkerWPF/">MarkPad</a>。</li><li>iOS 端很多 app 早已经支持了 Markdown 录入，例如 Drafts，Day One，iA writer 等，另外 Ulysses for iPad 现在已经上架，可以说是 iOS 平台最好的编辑器了。</li><li>在 Web 端，我强烈推荐 <a href="https://www.jianshu.com/">简书</a> 这款产品，上面有无数热爱文字的人在不停的创造，分享。在 Web 端使用 Markdown 没有比简书更舒服的地方了，同样支持左右两栏的实时预览，字体优雅，简洁。</li></ul><p><img src="https://image.loufengkai.top/siyuan/202302081151836.png" alt=""></p><p>简书的编辑预览模式</p><h2 id="二，Markdown-语法的简要规则"><a href="#二，Markdown-语法的简要规则" class="headerlink" title="二，Markdown 语法的简要规则"></a>二，Markdown 语法的简要规则</h2><h3 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h3><p><img src="https://image.loufengkai.top/siyuan/202302081151938.png" alt=""></p><p>标题</p><p>标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><p>以此类推，总共六级标题，建议在井号后加一个空格，这是最标准的 Markdown 语法。</p><h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加 1. 2. 3. 符号要和文字之间加上一个字符的空格。</p><p><img src="https://image.loufengkai.top/siyuan/202302081151313.png" alt=""></p><p>无序列表与有序列表</p><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>如果你需要引用一小段别处的句子，那么就要用引用的格式。</p><p>例如这样</p><p>只需要在文本前加入 &gt; 这种尖括号（大于号）即可</p><p><img src="https://image.loufengkai.top/siyuan/202302081151855.png" alt=""></p><p>引用</p><h3 id="图片与链接"><a href="#图片与链接" class="headerlink" title="图片与链接"></a>图片与链接</h3><p>插入链接与插入图片的语法很像，区别在一个 ! 号</p><p>图片为：<img src="" alt=""></p><p>链接为：<a href=""></a></p><p>插入图片的地址需要图床，这里推荐 <a href="https://link.jianshu.com/?t=http://weibotuchuang.sinaapp.com">围脖图床修复计划</a> 与 <a href="https://link.jianshu.com/?t=http://www.getcloudapp.com">CloudApp</a> 的服务，生成 URL 地址即可。</p><p><img src="https://image.loufengkai.top/siyuan/202302081151610.png" alt=""></p><p>URL 与图片</p><h3 id="粗体与斜体"><a href="#粗体与斜体" class="headerlink" title="粗体与斜体"></a>粗体与斜体</h3><p>Markdown 的粗体和斜体也非常简单，用两个 _包含一段文本就是粗体的语法，用一个_ 包含一段文本就是斜体的语法。</p><p>例如：这里是粗体 这里是斜体</p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>表格是我觉得 Markdown 比较累人的地方，例子如下：</p><div class="table-container"><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table></div><p>这种语法生成的表格如下：</p><p>Tables Are Cool</p><p>col 3 is</p><p>right-aligned</p><p>$1600</p><p>col 2 is</p><p>centered</p><p>$12</p><p>zebra stripes</p><p>are neat</p><p>$1</p><h3 id="代码框"><a href="#代码框" class="headerlink" title="代码框"></a>代码框</h3><p>如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown 下实现也非常简单，只需要用两个 ` 把中间的代码包裹起来。图例：</p><p><img src="https://image.loufengkai.top/siyuan/202302081152655.png" alt=""></p><p>使用 tab 键即可缩进。</p><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>分割线的语法只需要三个 * 号，例如：</p><p>到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。</p><p><img src="https://image.loufengkai.top/siyuan/202302081152949.png" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>其他</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL Server Management Studio (SSMS,SQL Server 管理工具）一直在加载程序包解决方案</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/SQL%20Server%20Management%20Studio%20(SSMS,SQL%20Server%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7)%20%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/%E5%85%B6%E4%BB%96/SQL%20Server%20Management%20Studio%20(SSMS,SQL%20Server%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7)%20%E4%B8%80%E7%9B%B4%E5%9C%A8%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F%E5%8C%85%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
    
    <content type="html"><![CDATA[<h1 id="SQL-Server-Management-Studio-SSMS-SQL-Server-管理工具）一直在加载程序包解决方案"><a href="#SQL-Server-Management-Studio-SSMS-SQL-Server-管理工具）一直在加载程序包解决方案" class="headerlink" title="SQL Server Management Studio (SSMS,SQL Server 管理工具）一直在加载程序包解决方案"></a>SQL Server Management Studio (SSMS,SQL Server 管理工具）一直在加载程序包解决方案</h1><p>在卸载 SSMS 管理工具后，重新安装会遇到 一直卡在 “正在加载程序包” 的状态<br><strong>解决方法</strong>就是 手动打开注册表 或者快捷方式 <code>win+r</code> 输入 <code>regedit</code><br>依次找到 <code>\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\</code> 目录<br>然后把 Microsoft SQL Server Management Studio 整个目录删除掉 再重新启动 SSMS 安装程序即可</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL server</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>十进制转成二进制的两种方式</title>
    <link href="/%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html"/>
    <url>/%E7%BC%96%E7%A8%8B/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%8D%81%E8%BF%9B%E5%88%B6%E8%BD%AC%E4%BA%8C%E8%BF%9B%E5%88%B6.html</url>
    
    <content type="html"><![CDATA[<h1 id="十进制转成二进制的两种方式"><a href="#十进制转成二进制的两种方式" class="headerlink" title="十进制转成二进制的两种方式"></a>十进制转成二进制的两种方式</h1><h2 id="第一种：用-2-整除的方式"><a href="#第一种：用-2-整除的方式" class="headerlink" title="第一种：用 2 整除的方式"></a>第一种：用 2 整除的方式</h2><p>用 2 整除十进制整数，得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此重复，直到商为小于 1 时为止，然后把先得到余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，以此排列起来。</p><p>注 1：当一个整数除另一个整数得到整数商而没有余数时，叫做整除。如 2 除 6 得 3，就说 2 能整除 6 或 6 能被 2 整除。</p><p>注 2：除以是被除数在前，除数在后；除是除数在前，被除数在后。如 32÷8=4 可描述为：8 除 32 等于 4，或者 32 除以 8 等于 4。</p><p>以十进制 100 转换为二进制为例：</p><p>100/2=50 余 0；50/2=25 余 0；25/2=12 余 1；12/2=6 余 0；6/2=3 余 0；3/2=1 余 1。以此排列十进制的 100 转换成二进制是：1100100。</p><p>计算如下：</p><p><img src="https://image.loufengkai.top/siyuan/202305080950367.png" alt=""></p><h2 id="第二种：1248-比表法（学名不知道，自己取的）"><a href="#第二种：1248-比表法（学名不知道，自己取的）" class="headerlink" title="第二种：1248 比表法（学名不知道，自己取的）"></a>第二种：1248 比表法（学名不知道，自己取的）</h2><p>对比表如下：</p><p><img src="https://image.loufengkai.top/siyuan/202305080952380.png" alt=""></p><p>以十进制 100 转换为二进制为例：</p><p>从左至右依次开始：100 比 128 小，取 0；100 比 64 大，取 1，剩 36；36 比 32 大，取 1，剩 4；4 比 16 小，取 0；4 比 8 小，取 0；4 不比 4 小，取 1，剩 0；0 比 2 小，取 0；0 比 1 小，取 0。最终得：01100100。</p><p><img src="https://image.loufengkai.top/siyuan/202305080954940.png" alt=""></p><p>得：1100100</p><p>又如十进制 168 转换为二进制：</p><p><img src="https://image.loufengkai.top/siyuan/202305080956394.png" alt=""></p><p>得：10101000</p>]]></content>
    
    
    <categories>
      
      <category>学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>进制转换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 安装 MySQL</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MySQL.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Docker/Docker%E5%AE%89%E8%A3%85MySQL.html</url>
    
    <content type="html"><![CDATA[<ol><li>下载 MySQL 镜像<br><img src="https://image.loufengkai.top/siyuan/202302182219354.png" alt="下载 MySQL 镜像"></li><li>准备映射目录<br>群晖目录下自己选择个地方创建这三个目录，分别用于存储配置文件、数据、错误日志。在创建容器时会用到它们并给对应的映射关系<br><img src="https://image.loufengkai.top/siyuan/202302182221314.png" alt="添加三个映射目录"></li><li>创建容器</li></ol><ul><li>双击镜像列表 mysql 开始创建<br><img src="https://image.loufengkai.top/siyuan/202302182223376.png" alt="开始创建"></li><li>在变量中添加“MYSQL_ROOT_PASSWORD”变量，值为密码<br><img src="https://image.loufengkai.top/siyuan/202302182224242.png" alt="添加“MYSQL_ROOT_PASSWORD”变量"></li><li>添加端口映射<br><img src="https://image.loufengkai.top/siyuan/202302182226276.png" alt="端口映射"></li><li>添加文件夹映射<br><img src="https://image.loufengkai.top/siyuan/202302182227602.png" alt="文件夹映射"></li></ul><ol><li>启动容器<br><img src="https://image.loufengkai.top/siyuan/202302182228878.png" alt="启动 MySQL 容器"></li></ol>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 升级版本（windows）</title>
    <link href="/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%EF%BC%88windows%EF%BC%89.html"/>
    <url>/%E8%BD%AF%E4%BB%B6%E6%95%99%E7%A8%8B/Git/Git%E5%8D%87%E7%BA%A7%E7%89%88%E6%9C%AC%EF%BC%88windows%EF%BC%89.html</url>
    
    <content type="html"><![CDATA[<h2 id="一、从官网下载最新安装包"><a href="#一、从官网下载最新安装包" class="headerlink" title="一、从官网下载最新安装包"></a>一、从官网下载最新安装包</h2><p>在 git 官网下载安装包并安装。Git For Windows 最新下载地址。下载下来后，双击开始，然后一直点下一步，完事。</p><h2 id="二、【推荐】通过升级命令一键更新"><a href="#二、【推荐】通过升级命令一键更新" class="headerlink" title="二、【推荐】通过升级命令一键更新"></a>二、【推荐】通过升级命令一键更新</h2><p>按 windows 键+S 键，在弹出的界面输入 Git Bash，然后输入下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git update-git-for-windows<br></code></pre></td></tr></table></figure><p>它就会开始自动下载了：</p><p>​<img src="https://image.loufengkai.top/siyuan/202301152207180.png" alt="">​</p>]]></content>
    
    
    <categories>
      
      <category>软件教程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>由于 i++ 与++i 的运算顺序不同而导致的死循环</title>
    <link href="/%E7%BC%96%E7%A8%8B/Csharp/%E7%94%B1%E4%BA%8Ei++%E4%B8%8E++i%E7%9A%84%E8%BF%90%E7%AE%97%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.html"/>
    <url>/%E7%BC%96%E7%A8%8B/Csharp/%E7%94%B1%E4%BA%8Ei++%E4%B8%8E++i%E7%9A%84%E8%BF%90%E7%AE%97%E9%A1%BA%E5%BA%8F%E4%B8%8D%E5%90%8C%E8%80%8C%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E5%BE%AA%E7%8E%AF.html</url>
    
    <content type="html"><![CDATA[<p>死循环的原因：i++ 和 ++i 的基本功能是相同的，都是对变量 i 进行自增 1 运算，从功能上讲相当于 i =i+1 ;<br>两个的区别在于：int i=1,a=0;<br>i++ 先运算在赋值，例如 a=i++, 先运算 a=i, 后运算 i=i+1, 所以结果是 a == 1；<br>++i 先赋值在运算，例如 a=++i, 先运算 i=i+1, 后运算 a=i, 所以结果是 a == 2。</p><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultEntity <span class="hljs-title">SyncDataXml</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> interfaceCode, SyncDataParam param</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> curPage = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> nextPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> totalPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(param.Page != <span class="hljs-number">0</span>)<br>     &#123;<br>         curPage = param.Page;<br>         nextPage = curPage++;<span class="hljs-comment">// 死循环的原因</span><br>     &#125;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">if</span>(nextPage &lt;= totalPage)<br>     &#123;<br>         <span class="hljs-keyword">var</span> nextParam = <span class="hljs-keyword">new</span> SyncDataParam<br>         &#123;<br>             LastUpdateTime = param.LastUpdateTime,<br>             Page = nextPage<br>             &#125;;<br>         result = SyncDataXml(interfaceCode, nextParam);<br>     &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> ResultEntity <span class="hljs-title">SyncDataXml</span>(<span class="hljs-params"><span class="hljs-built_in">string</span> interfaceCode, SyncDataParam param</span>)</span><br>&#123;<br>    <span class="hljs-built_in">int</span> curPage = <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">int</span> nextPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">int</span> totalPage = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(param.Page != <span class="hljs-number">0</span>)<br>     &#123;<br>         curPage = param.Page;<br>         nextPage = ++curPage;<span class="hljs-comment">// 解决</span><br>     &#125;<br>    <span class="hljs-comment">//递归</span><br>    <span class="hljs-keyword">if</span>(nextPage &lt;= totalPage)<br>     &#123;<br>         <span class="hljs-keyword">var</span> nextParam = <span class="hljs-keyword">new</span> SyncDataParam<br>         &#123;<br>             LastUpdateTime = param.LastUpdateTime,<br>             Page = nextPage<br>             &#125;;<br>         result = SyncDataXml(interfaceCode, nextParam);<br>     &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><hr>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 SQL 存储过程完整流程</title>
    <link href="/%E7%BC%96%E7%A8%8B/SQL/%E4%BD%BF%E7%94%A8SQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.html"/>
    <url>/%E7%BC%96%E7%A8%8B/SQL/%E4%BD%BF%E7%94%A8SQL%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B.html</url>
    
    <content type="html"><![CDATA[<ul><li>新建存储过程</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs sql">USE [数据库名]<br>GO<br><span class="hljs-keyword">create</span> proc myinsert <span class="hljs-comment">-- 创建一个存储过程，名称为 myinsert</span><br>    <span class="hljs-variable">@username</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<span class="hljs-comment">--注意这里的逗号，多个参数用逗号隔开</span><br>    <span class="hljs-variable">@password</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-variable">@name</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-variable">@usertype</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>),<br>    <span class="hljs-variable">@createpeople</span> <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)<span class="hljs-comment">--这里写参数，如果有的话；没有的话就空着</span><br>    <span class="hljs-keyword">as</span><br>    <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> SystemUsers(UserName,PassWord,Name,UserType,CreatPeople)<br>    <span class="hljs-keyword">values</span>(<span class="hljs-variable">@username</span>,<span class="hljs-variable">@password</span>,<span class="hljs-variable">@name</span>,<span class="hljs-variable">@usertype</span>,<span class="hljs-variable">@createpeople</span>)<br>    <span class="hljs-comment">--这里写具体语句，可以写 N 个</span><br>    go<span class="hljs-comment">--可加可不加，go 的意思是另起一页，相当于下一个功能块。如果下边不写语句，可以不加！</span><br></code></pre></td></tr></table></figure><ul><li>C# 调用存储过程</li></ul><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-built_in">string</span> strsql = <span class="hljs-string">&quot;Data Source=localhost;Initial Catalog=######;Integrated Security=True&quot;</span>;<span class="hljs-comment">//数据库链接字符串</span><br><span class="hljs-built_in">string</span> sql = <span class="hljs-string">&quot;SelectUserName&quot;</span>;<span class="hljs-comment">//要调用的存储过程名</span><br>SqlConnection conStr = <span class="hljs-keyword">new</span> SqlConnection(strsql);<span class="hljs-comment">//SQL 数据库连接对象，以数据库链接字符串为参数</span><br>SqlCommand comStr = <span class="hljs-keyword">new</span> SqlCommand(sql, conStr);<span class="hljs-comment">//SQL 语句执行对象，第一个参数是要执行的语句，第二个是数据库连接对象</span><br>comStr.CommandType = CommandType.StoredProcedure;<span class="hljs-comment">//因为要使用的是存储过程，所以设置执行类型为存储过程</span><br><span class="hljs-comment">//依次设定存储过程的参数</span><br>comStr.Parameters.Add(<span class="hljs-string">&quot;@Param1&quot;</span>, SqlDbType.Text).Value = <span class="hljs-string">&quot;####&quot;</span>;<br>conStr.Open();<span class="hljs-comment">//打开数据库连接</span><br><span class="hljs-comment">//执行存储过程</span><br>SqlDataAdapter SqlDataAdapter1 = <span class="hljs-keyword">new</span> SqlDataAdapter(comStr);<br>DataTable DT=<span class="hljs-keyword">new</span> DataTable ();<br>SqlDataAdapter1.Fill(DT);<br>dataGridView1.DataSource = DT;<br>conStr.Close();<span class="hljs-comment">//关闭连接</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL 两表之间：根据一个表的字段更新另一个表的字段</title>
    <link href="/%E7%BC%96%E7%A8%8B/SQL/SQL%E4%B8%A4%E8%A1%A8%E4%B9%8B%E9%97%B4%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5.html"/>
    <url>/%E7%BC%96%E7%A8%8B/SQL/SQL%E4%B8%A4%E8%A1%A8%E4%B9%8B%E9%97%B4%EF%BC%9A%E6%A0%B9%E6%8D%AE%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%8F%A6%E4%B8%80%E4%B8%AA%E8%A1%A8%E7%9A%84%E5%AD%97%E6%AE%B5.html</url>
    
    <content type="html"><![CDATA[<ul><li>写法轻松，更新效率高：</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> table1<br><span class="hljs-keyword">set</span> field1<span class="hljs-operator">=</span>table2.field1,<br>field2<span class="hljs-operator">=</span>table2.field2<br><span class="hljs-keyword">from</span> table2<br><span class="hljs-keyword">where</span> table1.id<span class="hljs-operator">=</span>table2.id<br></code></pre></td></tr></table></figure><ul><li>常规方式，另一种写法相当于一个 Left join，以外面的 where 为更新条数，如果不加 where 就是所有记录</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> table1<br><span class="hljs-keyword">set</span> field1<span class="hljs-operator">=</span>(<span class="hljs-keyword">select</span> top <span class="hljs-number">1</span> field1 <span class="hljs-keyword">from</span> table2 <span class="hljs-keyword">where</span> table2.id<span class="hljs-operator">=</span>table1.id)<br><span class="hljs-keyword">where</span> table1.id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">condition</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>以换行 (`\r\n`) 拆分字符串</title>
    <link href="/%E7%BC%96%E7%A8%8B/Csharp/%E4%BB%A5%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%8F%B7%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2.html"/>
    <url>/%E7%BC%96%E7%A8%8B/Csharp/%E4%BB%A5%E6%8D%A2%E8%A1%8C%E7%AC%A6%E5%8F%B7%E6%8B%86%E5%88%86%E5%AD%97%E7%AC%A6%E4%B8%B2.html</url>
    
    <content type="html"><![CDATA[<h2 id="以换行-r-n-拆分字符串"><a href="#以换行-r-n-拆分字符串" class="headerlink" title="以换行 (\r\n) 拆分字符串"></a>以换行 (<code>\r\n</code>) 拆分字符串</h2><hr><h2 id="字符串数组形式"><a href="#字符串数组形式" class="headerlink" title="字符串数组形式"></a>字符串数组形式</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Csharp"><span class="hljs-built_in">string</span>[] striparr = strip.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;\r\n&quot;</span> &#125;, StringSplitOptions.None);<br><br>striparr = striparr.Where(s =&gt; !<span class="hljs-built_in">string</span>.IsNullOrEmpty(s)).ToArray();<br></code></pre></td></tr></table></figure><hr><h2 id="List形式"><a href="#List形式" class="headerlink" title="List形式"></a>List<sting>形式</h2><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs Csharp">List&lt;<span class="hljs-built_in">string</span>&gt; striparr = strip.Split(<span class="hljs-keyword">new</span> <span class="hljs-built_in">string</span>[] &#123; <span class="hljs-string">&quot;\r\n&quot;</span> &#125;, StringSplitOptions.None).ToList();<br><br>striparr = striparr.Where(s =&gt; !<span class="hljs-built_in">string</span>.IsNullOrEmpty(s)).ToList();<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C#</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
